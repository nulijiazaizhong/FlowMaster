<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- æ·»åŠ ç½‘ç«™å›¾æ ‡ -->
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="apple-touch-icon" href="favicon.png">
    
    <!-- SEO Meta æ ‡ç­¾ -->
    <title>FlowMaster | ä¸“ä¸šçš„ç½‘ç»œæµé‡å®æ—¶ç›‘æ§ç³»ç»Ÿ</title>
    <meta name="description" content="FlowMasteræ˜¯ä¸€æ¬¾ä¸“ä¸šçš„ç½‘ç»œæµé‡ç›‘æ§ç³»ç»Ÿï¼Œæä¾›å®æ—¶æµé‡ç»Ÿè®¡ã€å†å²æ•°æ®æŸ¥è¯¢ã€å¤šæ¥å£æ”¯æŒç­‰åŠŸèƒ½ï¼Œå¸®åŠ©æ‚¨æ›´å¥½åœ°ç®¡ç†å’Œåˆ†æç½‘ç»œæµé‡ã€‚">
    <meta name="keywords" content="FlowMaster,æµé‡ç›‘æ§,ç½‘ç»œç›‘æ§,æµé‡ç»Ÿè®¡,ç½‘ç»œæµé‡åˆ†æ,å®æ—¶ç›‘æ§">
    <meta name="author" content="vbskycn">
    
    <!-- Open Graph Meta æ ‡ç­¾ (ç”¨äºç¤¾äº¤åª’ä½“åˆ†äº«) -->
    <meta property="og:title" content="FlowMaster | ä¸“ä¸šçš„ç½‘ç»œæµé‡å®æ—¶ç›‘æ§ç³»ç»Ÿ">
    <meta property="og:description" content="ä¸“ä¸šçš„ç½‘ç»œæµé‡ç›‘æ§ç³»ç»Ÿï¼Œæä¾›å®æ—¶æµé‡ç»Ÿè®¡ã€å†å²æ•°æ®æŸ¥è¯¢ã€å¤šæ¥å£æ”¯æŒç­‰åŠŸèƒ½ã€‚">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://github.com/vbskycn/FlowMaster">
    
    <!-- Twitter Card Meta æ ‡ç­¾ -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="FlowMaster | ä¸“ä¸šçš„ç½‘ç»œæµé‡å®æ—¶ç›‘æ§ç³»ç»Ÿ">
    <meta name="twitter:description" content="ä¸“ä¸šçš„ç½‘ç»œæµé‡ç›‘æ§ç³»ç»Ÿï¼Œæä¾›å®æ—¶æµé‡ç»Ÿè®¡ã€å†å²æ•°æ®æŸ¥è¯¢ã€å¤šæ¥å£æ”¯æŒç­‰åŠŸèƒ½ã€‚">
    
    <!-- ç§»åŠ¨è®¾å¤‡ä¼˜åŒ– -->
    <meta name="theme-color" content="#4a90e2">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <!-- æœç´¢å¼•æ“æŒ‡ä»¤ -->
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://github.com/vbskycn/FlowMaster">

    <!-- ç»“æ„åŒ–æ•°æ® (JSON-LD) -->
    <script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "SoftwareApplication",
        "name": "FlowMaster",
        "description": "ä¸“ä¸šçš„ç½‘ç»œæµé‡å®æ—¶ç›‘æ§ç³»ç»Ÿï¼Œæä¾›å®æ—¶æµé‡ç»Ÿè®¡ã€å†å²æ•°æ®æŸ¥è¯¢ã€å¤šæ¥å£æ”¯æŒç­‰åŠŸèƒ½ã€‚",
        "applicationCategory": "NetworkMonitoringTool",
        "operatingSystem": "All",
        "author": {
            "@type": "Person",
            "name": "vbskycn",
            "url": "https://github.com/vbskycn"
        },
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        }
    }
    </script>

    <link href="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/twitter-bootstrap/5.1.3/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.bootcdn.net/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script>
    <script src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/vue/3.2.31/vue.global.min.js"></script>
    <script src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/axios/0.26.0/axios.min.js"></script>
    <link href="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/bootstrap-icons/1.8.0/font/bootstrap-icons.min.css" rel="stylesheet">
    <link href="/css/main.css" rel="stylesheet">
    <link href="/css/dark-theme.css" rel="stylesheet">
    
    <!-- æ–°å¢ï¼šèµ„æºé¢„åŠ è½½ä¼˜åŒ– -->
    <link rel="preload" href="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/twitter-bootstrap/5.1.3/css/bootstrap.min.css" as="style">
    <link rel="preload" href="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/vue/3.2.31/vue.global.min.js" as="script">
    <link rel="preload" href="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/axios/0.26.0/axios.min.js" as="script">
    
    <!-- æ–°å¢ï¼šæ€§èƒ½ç›‘æ§ -->
    <script>
        // æ€§èƒ½ç›‘æ§
        window.performanceMark = function(name) {
            if (window.performance && window.performance.mark) {
                window.performance.mark(name);
            }
        };
        
        // è®°å½•é¡µé¢åŠ è½½å¼€å§‹
        window.performanceMark('app-start');
    </script>
</head>
<body>
    <header class="container py-4">
        <div id="app">
            <div class="d-flex justify-content-between align-items-center mb-3">
                <div class="d-flex align-items-center">
                    <h1 class="mb-0">FlowMaster æµé‡ç›‘æ§</h1>
                    <span class="version-badge ms-3" v-cloak>v{{version}}</span>
                </div>
                <div class="refresh-control text-end">
                    <div class="form-check form-switch d-inline-block">
                        <input class="form-check-input" type="checkbox" v-model="autoRefresh" id="autoRefreshSwitch">
                        <label class="form-check-label" for="autoRefreshSwitch">
                            è‡ªåŠ¨åˆ·æ–°
                        </label>
                    </div>
                    <!-- ä¸»é¢˜åˆ‡æ¢å¼€å…³ -->
                    <button class="btn btn-sm ms-2" :class="isDarkMode ? 'btn-dark' : 'btn-light'" @click="toggleTheme" :aria-label="isDarkMode ? 'åˆ‡æ¢ä¸ºæµ…è‰²' : 'åˆ‡æ¢ä¸ºæ·±è‰²'" style="vertical-align:middle;">
                        <span v-if="isDarkMode">ğŸŒ™</span>
                        <span v-else>â˜€ï¸</span>
                    </button>
                    <!-- è°ƒè¯•æ¨¡å¼æŒ‰é’®å·²ç§»é™¤ -->
                    <div class="update-time" v-if="lastUpdateTime">
                        æœ€åæ›´æ–°: {{lastUpdateTime}}
                    </div>
                </div>
            </div>

            <div v-if="error" class="alert alert-danger" v-cloak>
                {{error}}
                <button class="btn btn-sm btn-outline-danger ms-2" @click="runDiagnosis" title="è¿è¡Œè¯Šæ–­">
                    <i class="bi bi-bug"></i> è¯Šæ–­é—®é¢˜
                </button>
            </div>

            <!-- æ–°å¢ï¼šè¯Šæ–­ç»“æœæ˜¾ç¤º -->
            <div v-if="diagnosisResult" class="alert alert-info" v-cloak>
                <h6>è¯Šæ–­ç»“æœ ({{diagnosisResult.timestamp}})</h6>
                <div v-if="diagnosisResult.serverStatus">
                    <strong>æœåŠ¡å™¨çŠ¶æ€:</strong> 
                    <span :class="diagnosisResult.serverStatus.success ? 'text-success' : 'text-danger'">
                        {{diagnosisResult.serverStatus.success ? 'è¿æ¥æ­£å¸¸' : 'è¿æ¥å¤±è´¥'}}
                    </span>
                    <span v-if="!diagnosisResult.serverStatus.success" class="text-muted">
                        ({{diagnosisResult.serverStatus.error}})
                    </span>
                </div>
                <div v-if="diagnosisResult.vnstatTest">
                    <strong>vnstatæµ‹è¯•:</strong> 
                    <span :class="diagnosisResult.vnstatTest.success ? 'text-success' : 'text-danger'">
                        {{diagnosisResult.vnstatTest.success ? 'æ­£å¸¸' : 'å¤±è´¥'}}
                    </span>
                </div>
                <div v-if="diagnosisResult.recommendations.length > 0">
                    <strong>å»ºè®®:</strong>
                    <ul class="mb-0 mt-1">
                        <li v-for="rec in diagnosisResult.recommendations" :key="rec">{{rec}}</li>
                    </ul>
                </div>
                <button class="btn btn-sm btn-outline-secondary mt-2" @click="diagnosisResult = null">
                    å…³é—­
                </button>
            </div>

            <div class="row align-items-center mb-3">
                <div class="col-md-4">
                    <select v-model="selectedInterface" class="form-select" @change="loadAllStats" v-cloak>
                        <option v-for="interface in interfaces" :key="interface" :value="interface">
                            {{interface}}
                        </option>
                    </select>
                </div>
                <div class="col-md-8">
                    <p class="text-muted mb-0 mt-2 mt-md-0" v-cloak>
                        å½“å‰é€‰æ‹©çš„ç½‘ç»œæ¥å£: {{selectedInterface}}
                    </p>
                </div>
            </div>

            <!-- æ–°å¢ï¼šç¼“å­˜çŠ¶æ€å’Œç³»ç»Ÿæ€§èƒ½æ˜¾ç¤º -->
            <div class="row mb-3" v-cloak>
                <div class="col-md-6">
                    <div class="card">
                        <div class="card-header py-2">
                            <h6 class="card-title mb-0">ç¼“å­˜çŠ¶æ€</h6>
                        </div>
                        <div class="card-body py-2">
                            <div class="row text-center">
                                <div class="col-3">
                                    <div class="small text-muted">å‘½ä¸­ç‡</div>
                                    <div class="fw-bold" :class="cacheStats.hitRate > '50%' ? 'text-success' : 'text-warning'">{{cacheStats.hitRate}}</div>
                                </div>
                                <div class="col-3">
                                    <div class="small text-muted">ç¼“å­˜æ¡ç›®</div>
                                    <div class="fw-bold">{{cacheStats.size}}/{{cacheStats.maxSize}}</div>
                                </div>
                                <div class="col-3">
                                    <div class="small text-muted">å†…å­˜ä½¿ç”¨</div>
                                    <div class="fw-bold">{{cacheStats.memoryUsage}}</div>
                                </div>
                                <div class="col-3">
                                    <button class="btn btn-sm btn-outline-secondary" @click="clearCache" title="æ¸…ç©ºç¼“å­˜">
                                        <i class="bi bi-trash"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="card">
                        <div class="card-header py-2">
                            <h6 class="card-title mb-0">ç³»ç»Ÿæ€§èƒ½</h6>
                        </div>
                        <div class="card-body py-2">
                            <div class="row text-center">
                                <div class="col-4">
                                    <div class="small text-muted">å“åº”æ—¶é—´</div>
                                    <div class="fw-bold" :class="performance.lastResponseTime < 100 ? 'text-success' : 'text-warning'">{{performance.lastResponseTime}}ms</div>
                                </div>
                                <div class="col-4">
                                    <div class="small text-muted">å¹³å‡å“åº”</div>
                                    <div class="fw-bold">{{performance.averageResponseTime.toFixed(0)}}ms</div>
                                </div>
                                <div class="col-4">
                                    <div class="small text-muted">è¯·æ±‚æ¬¡æ•°</div>
                                    <div class="fw-bold">{{performance.requestCount}}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card mb-3" v-cloak>
                <div class="card-header py-2">
                    <h6 class="mb-0">æŒ‡å®šæ—¥æœŸç»Ÿè®¡æ•°æ®æŒ‰å¤©æŸ¥è¯¢</h6>
                </div>
                <div class="card-body py-2">
                    <div class="row g-2 align-items-end">
                        <div class="col-md-3">
                            <label for="startDate" class="form-label small mb-1">å¼€å§‹æ—¥æœŸ</label>
                            <input type="date" class="form-control form-control-sm" id="startDate" v-model="dateRange.start">
                        </div>
                        <div class="col-md-3">
                            <label for="endDate" class="form-label small mb-1">ç»“æŸæ—¥æœŸ</label>
                            <input type="date" class="form-control form-control-sm" id="endDate" v-model="dateRange.end">
                        </div>
                        <div class="col-md-2">
                            <button type="button" class="btn btn-primary btn-sm w-100" @click="queryDateRange" :disabled="!isDateRangeValid">
                                æŸ¥è¯¢
                            </button>
                        </div>
                        <div class="col-md-2" v-if="dateRangeStats.data.length">
                            <button type="button" class="btn btn-outline-secondary btn-sm w-100" @click="clearDateRangeStats">
                                æ¸…é™¤
                            </button>
                        </div>
                    </div>
                    
                    <!-- æŸ¥è¯¢ç»“æœæ˜¾ç¤º -->
                    <div v-if="dateRangeStats.data.length" class="mt-3">
                        <!-- å›¾è¡¨æ˜¾ç¤º -->
                        <div class="chart-container" style="height:180px;margin-bottom:15px;">
                            <canvas ref="dateRangeChart" style="width:100%;height:100%;"></canvas>
                        </div>
                        <!-- è¡¨æ ¼æ˜¾ç¤º -->
                        <div v-html="renderTableHtml(formatTableDataUnified(dateRangeStats.data, dateRangeStats.unit, dateRangeStats.factor), dateRangeStats.unit)"></div>
                    </div>
                </div>
            </div>

            <div class="row" v-cloak>
                <div class="col-md-12 mb-4">
                    <div class="card" :class="{ loading: realtimeStats.loading }">
                        <div class="card-header">
                            <h5 class="card-title mb-0">å®æ—¶ç»Ÿè®¡</h5>
                        </div>
                        <div class="card-body">
                            <!-- å®æ—¶æµé‡å›¾è¡¨ -->
                            <div class="chart-container" style="height:200px;margin-bottom:15px;">
                                <canvas ref="realtimeChart" style="width:100%;height:100%;"></canvas>
                            </div>
                            <!-- å®æ—¶æµé‡è¡¨æ ¼ -->
                            <div ref="realtimeTable" style="max-height:300px;overflow-y:auto;"></div>
                        </div>
                    </div>
                </div>

                <div class="col-md-12 mb-4">
                    <div class="card" :class="{ loading: minuteStats.loading }">
                        <div class="card-header">
                            <h5 class="card-title mb-0">åˆ†é’Ÿç»Ÿè®¡</h5>
                        </div>
                        <div class="card-body">
                            <div class="chart-container" style="height:180px;">
                                <canvas ref="minuteChart" style="width:100%;height:100%;"></canvas>
                            </div>
                            <div v-html="renderTableHtml(formatTableDataUnified(minuteStats.data, minuteStats.unit, minuteStats.factor), minuteStats.unit)"></div>
                        </div>
                    </div>
                </div>

                <div class="col-md-6 mb-4" v-for="(stat, index) in stats" :key="index">
                    <div class="card" :class="{ loading: stat.loading }">
                        <div class="card-header">
                            <h5 class="card-title mb-0">{{stat.title}}</h5>
                        </div>
                        <div class="card-body">
                            <div class="chart-container" :style="stat.period === 'y' ? 'height:320px;' : 'height:180px;'">
                                <canvas :ref="'statChart' + index" style="width:100%;height:100%;"></canvas>
                            </div>
                            <div v-html="renderTableHtml(formatTableDataUnified(stat.data, stat.unit, stat.factor), stat.unit)"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <main role="main">
        <!-- ... åŸæœ‰çš„ä¸»è¦å†…å®¹ ... -->
    </main>

    <footer class="footer" role="contentinfo">
        <div class="container">
            <div class="footer-content">
                <div class="footer-brand">
                    <span class="footer-text">FlowMaster</span>
                    <span class="version-badge ms-2" v-cloak>v{{version}}</span>
                    <span class="copyright-text ms-3">Â© 2025 by 
                        <a href="https://www.zhoujie218.top" target="_blank" class="author-link">zhoujie218</a>
                    </span>
                </div>
                <a href="https://github.com/vbskycn/FlowMaster" target="_blank" class="github-link">
                    <i class="bi bi-github"></i> GitHub
                </a>
            </div>
        </div>
    </footer>

    <!-- ä½¿ç”¨ç¨³å®šç‰ˆæœ¬çš„ Bootstrap Icons CDN -->
    

    <!-- Chart.js CDN -->
    

    <!-- æ›´æ–°é¡µè„šæ ·å¼ -->
    <!-- å·²åˆ†ç¦»è‡³main.csså’Œdark-theme.cssï¼Œæ— éœ€ä¿ç•™å†…è”æ ·å¼ -->

    <script>
        const app = Vue.createApp({
            data() {
                return {
                    interfaces: [],
                    selectedInterface: 'eth0',
                    error: null,
                    realtimeStats: { data: [], loading: false },
                    minuteStats: { data: [], loading: false },
                    stats: [
                        { period: 'h', title: 'å°æ—¶ç»Ÿè®¡', data: [], loading: false },
                        { period: 'd', title: 'æ—¥ç»Ÿè®¡', data: [], loading: false },
                        { period: 'm', title: 'æœˆç»Ÿè®¡', data: [], loading: false },
                        { period: 'y', title: 'å¹´ç»Ÿè®¡', data: [], loading: false }
                    ],
                    autoRefresh: true,
                    refreshInterval: null,
                    lastUpdateTime: '',
                    version: '',
                    dateRange: {
                        start: '',
                        end: ''
                    },
                    dateRangeStats: {
                        data: [],
                        loading: false,
                        unit: 'GiB',
                        factor: 1
                    },
                    isDarkMode: false,
                    realtimeData: [], // å­˜å‚¨æœ€è¿‘20æ¡å®æ—¶æ•°æ®è®°å½•
                    debugMode: false, // è°ƒè¯•æ¨¡å¼å¼€å…³
                    // æ–°å¢ï¼šç¼“å­˜çŠ¶æ€ç›¸å…³å­—æ®µ
                    cacheStats: {
                        hits: 0,
                        misses: 0,
                        hitRate: '0%',
                        size: 0,
                        maxSize: 100,
                        memoryUsage: '0MB',
                        maxMemory: '50MB'
                    },
                    systemMemory: {
                        rss: '0MB',
                        heapTotal: '0MB',
                        heapUsed: '0MB',
                        external: '0MB',
                        cacheMemory: '0MB'
                    },
                    performance: {
                        lastResponseTime: 0,
                        averageResponseTime: 0,
                        requestCount: 0
                    },
                    diagnosisResult: null, // æ–°å¢ï¼šè¯Šæ–­ç»“æœ
                    // æ–°å¢ï¼šæ€§èƒ½ä¼˜åŒ–ç›¸å…³å­—æ®µ
                    chartInstances: new Map(), // Chart.jså®ä¾‹æ± 
                    updateQueue: new Set(), // æ›´æ–°é˜Ÿåˆ—
                    isUpdating: false, // æ˜¯å¦æ­£åœ¨æ›´æ–°
                    lastChartUpdate: 0, // ä¸Šæ¬¡å›¾è¡¨æ›´æ–°æ—¶é—´
                    chartUpdateThrottle: 100 // å›¾è¡¨æ›´æ–°èŠ‚æµæ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
                }
            },
            computed: {
                isDateRangeValid() {
                    return this.dateRange.start && this.dateRange.end && 
                           this.dateRange.start <= this.dateRange.end;
                }
            },
            methods: {
                async loadInterfaces() {
                    try {
                        const response = await this.measurePerformance(() => 
                            axios.get('/api/interfaces')
                        );
                        // å¯¹æ¥å£åˆ—è¡¨è¿›è¡Œæ’åº
                        this.interfaces = response.data.interfaces.sort((a, b) => {
                            // å®šä¹‰æ¥å£ä¼˜å…ˆçº§å‡½æ•°
                            const getPriority = (name) => {
                                // å¸¸è§ç‰©ç†ç½‘å¡æ¥å£ä¼˜å…ˆ
                                if (name.startsWith('eth')) return 1;
                                if (name.startsWith('ens')) return 2;
                                if (name.startsWith('enp')) return 3;
                                // å…¶ä»–å¸¸è§ç½‘å¡æ¥å£
                                if (name.startsWith('wlan')) return 10;
                                if (name.startsWith('bond')) return 11;
                                if (name.startsWith('br-')) return 12;
                                // è™šæ‹Ÿå’Œå®¹å™¨æ¥å£é å
                                if (name.startsWith('docker')) return 100;
                                if (name.includes('veth') || 
                                    name.includes('virbr') || 
                                    name.includes('tun') || 
                                    name.includes('tap')) return 101;
                                return 50; // å…¶ä»–æ¥å£
                            };
                            
                            const priorityA = getPriority(a);
                            const priorityB = getPriority(b);
                            
                            // é¦–å…ˆæŒ‰ä¼˜å…ˆçº§æ’åº
                            if (priorityA !== priorityB) {
                                return priorityA - priorityB;
                            }
                            
                            // ä¼˜å…ˆçº§ç›¸åŒæ—¶æŒ‰å­—æ¯é¡ºåºæ’åº
                            return a.localeCompare(b);
                        });

                        // é€‰æ‹©ç¬¬ä¸€ä¸ªæ¥å£ä½œä¸ºé»˜è®¤å€¼
                        if (this.interfaces.length > 0) {
                            this.selectedInterface = this.interfaces[0];
                            this.loadAllStats();
                        } else {
                            // é™çº§æ˜¾ç¤ºï¼šå¦‚æœæ²¡æœ‰æ‰¾åˆ°æ¥å£ï¼Œæ˜¾ç¤ºé»˜è®¤æ¥å£
                            this.interfaces = ['eth0'];
                            this.selectedInterface = 'eth0';
                            this.error = 'æœªæ‰¾åˆ°ç½‘ç»œæ¥å£ï¼Œä½¿ç”¨é»˜è®¤æ¥å£eth0ã€‚è¯·æ£€æŸ¥vnstatæ˜¯å¦æ­£ç¡®å®‰è£…å’Œé…ç½®ã€‚';
                        }
                    } catch (error) {
                        const errorMsg = error.response?.data?.error || error.message;
                        this.error = `æ— æ³•è·å–ç½‘ç»œæ¥å£åˆ—è¡¨: ${errorMsg}`;
                        console.error('æ¥å£åˆ—è¡¨åŠ è½½å¤±è´¥:', error);
                        
                        // å¦‚æœæ˜¯ç¼“å­˜ç›¸å…³é”™è¯¯ï¼Œæä¾›ç‰¹æ®Šæç¤º
                        if (errorMsg.includes('cache') || errorMsg.includes('ç¼“å­˜')) {
                            this.error += ' (ç¼“å­˜ç³»ç»Ÿå¯èƒ½å­˜åœ¨é—®é¢˜)';
                        }
                        
                        // é™çº§æ˜¾ç¤ºï¼šä½¿ç”¨é»˜è®¤æ¥å£
                        this.interfaces = ['eth0'];
                        this.selectedInterface = 'eth0';
                        
                        // è‡ªåŠ¨è¿è¡Œè¯Šæ–­
                        setTimeout(() => {
                            this.runDiagnosis();
                        }, 1000);
                    }
                },
                parseStatData(data, unit = 'MiB') {
                    // ä¼˜åŒ–ï¼šé¢„åˆ†é…æ•°ç»„å¤§å°ï¼Œå‡å°‘åŠ¨æ€æ‰©å®¹
                    const labels = [];
                    const rx = [];
                    const tx = [];
                    let headerIdx = -1;
                    let rxIdx = -1, txIdx = -1, labelIdx = 0;
                    let started = false;
                    
                    // ä¼˜åŒ–ï¼šä½¿ç”¨forå¾ªç¯æ›¿ä»£forEachï¼Œæ€§èƒ½æ›´å¥½
                    for (let i = 0; i < data.length; i++) {
                        const line = data[i].trim();
                        if (!line) continue;
                        if (line.includes('---')) { started = true; continue; }
                        if (!started) {
                            // è¯†åˆ«è¡¨å¤´
                            headerIdx = i;
                            const header = data[i].replace(/\s+/g, ' ').trim().split(' ');
                            rxIdx = header.findIndex(h => h.startsWith('æ¥æ”¶'));
                            txIdx = header.findIndex(h => h.startsWith('å‘é€'));
                            labelIdx = 0; // é€šå¸¸ç¬¬ä¸€ä¸ªæ˜¯æ—¶é—´/æ—¥æœŸ
                            continue;
                        }
                        // è§£ææ•°æ®è¡Œ
                        const cols = line.replace(/\s+/g, ' ').trim().split(' ');
                        if (cols.length < Math.max(rxIdx, txIdx) + 1) continue;
                        // è·³è¿‡åˆè®¡/å¹³å‡/é¢„è®¡ç­‰è¡Œ
                        if (/æ€»è®¡|å¹³å‡|é¢„è®¡|total|avg|est|sum/.test(cols[labelIdx])) continue;
                        labels.push(cols[labelIdx]);
                        rx.push(this.extractPureNumber(cols[rxIdx]));
                        tx.push(this.extractPureNumber(cols[txIdx]));
                    }
                    return { labels, rx, tx };
                },
                extractPureNumber(val) {
                    // ä¼˜åŒ–ï¼šä½¿ç”¨æ›´é«˜æ•ˆçš„æ­£åˆ™åŒ¹é…
                    if (!val) return 0;
                    const match = val.match(/([\d.]+)/);
                    return match ? parseFloat(match[1]) : 0;
                },
                getBestUnitAndFactor(arr) {
                    // ä¼˜åŒ–ï¼šä½¿ç”¨Math.maxçš„å±•å¼€è¯­æ³•ï¼Œæ€§èƒ½æ›´å¥½
                    const max = Math.max(...arr);
                    if (max >= 1024 * 1024) return { unit: 'TiB', factor: 1 / (1024 * 1024) };
                    if (max >= 1024) return { unit: 'GiB', factor: 1 / 1024 };
                    return { unit: 'MiB', factor: 1 };
                },
                // ä¼˜åŒ–ï¼šæ ¼å¼åŒ–è¡¨æ ¼æ•°æ®ä¸ºç»Ÿä¸€å•ä½ä¸”ç§»é™¤åŸå§‹å•ä½
                formatTableDataUnified(data, unit, factor) {
                    // ä¼˜åŒ–ï¼šé¢„åˆ†é…æ•°ç»„å¤§å°
                    const result = new Array(data.length);
                    let started = false;
                    let rxIdx = -1, txIdx = -1, totalIdx = -1;
                    
                    for (let i = 0; i < data.length; i++) {
                        let line = data[i];
                        if (!started && line.includes('---')) { 
                            started = true; 
                            result[i] = line; 
                            continue; 
                        }
                        if (!started) {
                            // å¤„ç†è¡¨å¤´ï¼Œæ ‡æ³¨å•ä½
                            let header = line.replace(/\s+/g, ' ').trim().split(' ');
                            rxIdx = header.findIndex(h => h === 'æ¥æ”¶' || h.toLowerCase() === 'rx');
                            txIdx = header.findIndex(h => h === 'å‘é€' || h.toLowerCase() === 'tx');
                            totalIdx = header.findIndex(h => h === 'æ€»è®¡' || h.toLowerCase() === 'total');
                            if (rxIdx !== -1) header[rxIdx] += `(${unit})`;
                            if (txIdx !== -1) header[txIdx] += `(${unit})`;
                            if (totalIdx !== -1) header[totalIdx] += `(${unit})`;
                            result[i] = header.join(' ');
                            continue;
                        }
                        // åªå¤„ç†æ•°æ®è¡Œ
                        let cols = line.replace(/\s+/g, ' ').trim().split(' ');
                        if (cols.length < Math.max(rxIdx, txIdx, totalIdx) + 1) { 
                            result[i] = line; 
                            continue; 
                        }
                        // è·³è¿‡åˆè®¡/å¹³å‡/é¢„è®¡ç­‰è¡Œ
                        if (/æ€»è®¡|å¹³å‡|é¢„è®¡|total|avg|est|sum/.test(cols[0])) { 
                            result[i] = line; 
                            continue; 
                        }
                        // æ ¼å¼åŒ–æ•°å€¼å¹¶ç§»é™¤åŸå•ä½
                        if (rxIdx !== -1) cols[rxIdx] = this.formatValueToUnitNoUnit(cols[rxIdx], factor);
                        if (txIdx !== -1) cols[txIdx] = this.formatValueToUnitNoUnit(cols[txIdx], factor);
                        if (totalIdx !== -1) cols[totalIdx] = this.formatValueToUnitNoUnit(cols[totalIdx], factor);
                        result[i] = cols.join(' ');
                    }
                    return result;
                },
                formatValueToUnitNoUnit(val, factor) {
                    // ä¼˜åŒ–ï¼šä½¿ç”¨æ›´é«˜æ•ˆçš„æ­£åˆ™åŒ¹é…
                    const match = val.match(/([\d.]+)/);
                    if (!match) return val;
                    const num = parseFloat(match[1]);
                    return isNaN(num) ? val : (num * factor).toFixed(2);
                },
                // æ–°å¢ï¼šå¥å£®çš„å›¾è¡¨æ¸²æŸ“å‡½æ•°ï¼Œè‡ªåŠ¨é‡è¯•3æ¬¡
                safeRenderChart(renderFunc, chartKey, tryCount = 0) {
                    try {
                        renderFunc();
                    } catch (e) {
                        if (this.debugMode) {
                            console.warn(`Chartæ¸²æŸ“å¤±è´¥[${chartKey}]ï¼Œç¬¬${tryCount+1}æ¬¡:`, e);
                        }
                        if (tryCount < 3) {
                            setTimeout(() => this.safeRenderChart(renderFunc, chartKey, tryCount + 1), 100);
                        } else if (this.debugMode) {
                            console.error(`Chartæ¸²æŸ“å¤šæ¬¡é‡è¯•ä»å¤±è´¥[${chartKey}]`);
                        }
                    }
                },
                // ä¼˜åŒ–åçš„ renderMinuteChart
                renderMinuteChart() {
                    this.safeRenderChart(() => {
                        const chartKey = 'minuteChart';
                        let ctx = this.$refs.minuteChart;
                        if (!ctx) {
                            if (this.debugMode) console.warn('minuteChart ref ä¸å­˜åœ¨');
                            throw new Error('minuteChart ref ä¸å­˜åœ¨');
                        }
                        ctx.height = 180;
                        const parent = ctx.parentElement;
                        if (parent) ctx.width = parent.clientWidth;
                        const unit = 'MiB';
                        const { labels, rx, tx } = this.parseStatData(this.minuteStats.data, unit);
                        if (!labels.length) {
                            if (this.debugMode) console.warn('minuteChart æ•°æ®ä¸ºç©º');
                            throw new Error('minuteChart æ•°æ®ä¸ºç©º');
                        }
                        const existingChart = this.getChartInstance(chartKey);
                        if (existingChart) existingChart.destroy();
                        const chart = new Chart(ctx, {
                            type: 'line',
                            data: {
                                labels,
                                datasets: [
                                    { label: `æ¥æ”¶(${unit})`, data: rx, borderColor: '#2563eb', backgroundColor: 'rgba(37,99,235,0.08)', tension: 0.3, fill: true },
                                    { label: `å‘é€(${unit})`, data: tx, borderColor: '#fb923c', backgroundColor: 'rgba(251,146,60,0.08)', tension: 0.3, fill: true }
                                ]
                            },
                            options: {
                                responsive: true,
                                plugins: { legend: { display: true }, tooltip: { enabled: true } },
                                scales: { y: { beginAtZero: true, title: { display: true, text: unit } } }
                            }
                        });
                        this.setChartInstance(chartKey, chart);
                    }, 'minuteChart');
                },
                // ä¼˜åŒ–åçš„ renderStatChart
                renderStatChart(index) {
                    this.safeRenderChart(() => {
                        const chartKey = `statChart${index}`;
                        let ctx = this.$refs['statChart' + index];
                        if (Array.isArray(ctx)) ctx = ctx[0];
                        if (!ctx) {
                            if (this.debugMode) console.warn(`statChart${index} ref ä¸å­˜åœ¨`);
                            throw new Error(`statChart${index} ref ä¸å­˜åœ¨`);
                        }
                        const period = this.stats[index].period;
                        ctx.height = period === 'y' ? 320 : 180;
                        const parent = ctx.parentElement;
                        if (parent) ctx.width = parent.clientWidth;
                        let unit = 'MiB';
                        if (period === 'd' || period === 'm') unit = 'GiB';
                        if (period === 'y') unit = 'TiB';
                        const { labels, rx, tx } = this.parseStatData(this.stats[index].data, unit);
                        if (!labels.length) {
                            if (this.debugMode) console.warn(`statChart${index} æ•°æ®ä¸ºç©º`);
                            throw new Error(`statChart${index} æ•°æ®ä¸ºç©º`);
                        }
                        const existingChart = this.getChartInstance(chartKey);
                        if (existingChart) existingChart.destroy();
                        const chartType = period === 'y' ? 'bar' : 'line';
                        const chart = new Chart(ctx, {
                            type: chartType,
                            data: {
                                labels,
                                datasets: [
                                    { label: `æ¥æ”¶(${unit})`, data: rx, backgroundColor: period === 'y' ? '#2563eb' : 'rgba(37,99,235,0.08)', borderColor: '#2563eb', tension: 0.3, fill: period !== 'y' },
                                    { label: `å‘é€(${unit})`, data: tx, backgroundColor: period === 'y' ? '#fb923c' : 'rgba(251,146,60,0.08)', borderColor: '#fb923c', tension: 0.3, fill: period !== 'y' }
                                ]
                            },
                            options: {
                                responsive: true,
                                plugins: { legend: { display: true }, tooltip: { enabled: true } },
                                scales: { y: { beginAtZero: true, title: { display: true, text: unit } } }
                            }
                        });
                        this.setChartInstance(chartKey, chart);
                    }, `statChart${index}`);
                },
                // æ–°å¢ï¼šç»Ÿä¸€é‡ç»˜æ‰€æœ‰å›¾è¡¨ï¼ˆçª—å£resizeæ—¶è°ƒç”¨ï¼‰
                resizeAllCharts() {
                    // é‡æ–°æ¸²æŸ“åˆ†é’Ÿå›¾è¡¨
                    this.$nextTick(() => {
                        this.renderMinuteChart();
                        // é‡æ–°æ¸²æŸ“æ‰€æœ‰ç»Ÿè®¡å›¾è¡¨
                        if (this.stats && this.stats.length) {
                            this.stats.forEach((stat, idx) => this.renderStatChart(idx));
                        }
                    });
                },
                async loadStats(stat, index) {
                    stat.loading = true;
                    try {
                        const response = await axios.get(`/api/stats/${this.selectedInterface}/${stat.period}`);
                        stat.data = response.data.data;
                        this.$nextTick(() => this.renderStatChart(index));
                        // ç»Ÿä¸€å•ä½
                        const { labels, rx, tx } = this.parseStatData(stat.data);
                        const all = rx.concat(tx);
                        const { unit, factor } = this.getBestUnitAndFactor(all);
                        stat.unit = unit;
                        stat.factor = factor;
                    } catch (error) {
                        stat.data = ['é”™è¯¯: ' + (error.response?.data?.error || error.message)];
                    }
                    stat.loading = false;
                },
                async loadRealtimeStats() {
                    this.realtimeStats.loading = true;
                    try {
                        if (this.debugMode) console.log('å¼€å§‹åŠ è½½å®æ—¶ç»Ÿè®¡æ•°æ®...');
                        const response = await axios.get(`/api/stats/${this.selectedInterface}/l`);
                        
                        // è§£æå®æ—¶æ•°æ®
                        const rawData = response.data.data;
                        if (this.debugMode) console.log('æ”¶åˆ°åŸå§‹å®æ—¶æ•°æ®:', rawData);
                        
                        const parsedData = this.parseRealtimeData(rawData);
                        
                        if (parsedData) {
                            // æ·»åŠ åˆ°å†å²æ•°æ®ï¼Œä¿æŒæœ€è¿‘20æ¡
                            this.realtimeData.push(parsedData);
                            if (this.realtimeData.length > 20) {
                                this.realtimeData.shift();
                            }
                            
                            if (this.debugMode) console.log('å®æ—¶æ•°æ®è§£ææˆåŠŸï¼Œå½“å‰å†å²æ•°æ®æ¡æ•°:', this.realtimeData.length);
                            
                            // æ›´æ–°å›¾è¡¨å’Œè¡¨æ ¼
                            this.$nextTick(() => {
                                this.renderRealtimeChart();
                                this.renderRealtimeTable();
                            });
                        } else {
                            if (this.debugMode) console.warn('å®æ—¶æ•°æ®è§£æå¤±è´¥ï¼Œä½†ç»§ç»­æ˜¾ç¤ºåŸå§‹æ•°æ®');
                        }
                        
                        // ä¿æŒåŸæœ‰æ•°æ®æ ¼å¼ç”¨äºå…¼å®¹
                        this.realtimeStats.data = rawData.filter(line => line.trim());
                        
                        // ç¡®ä¿å›¾è¡¨å’Œè¡¨æ ¼å§‹ç»ˆæ›´æ–°
                        this.$nextTick(() => {
                            this.renderRealtimeChart();
                            this.renderRealtimeTable();
                        });
                        
                    } catch (error) {
                        console.error('åŠ è½½å®æ—¶ç»Ÿè®¡æ•°æ®å¤±è´¥:', error);
                        this.realtimeStats.data = ['é”™è¯¯: ' + (error.response?.data?.error || error.message)];
                        
                        // å³ä½¿å‡ºé”™ä¹Ÿè¦å°è¯•æ¸²æŸ“
                        this.$nextTick(() => {
                            this.renderRealtimeChart();
                            this.renderRealtimeTable();
                        });
                    }
                    this.realtimeStats.loading = false;
                },
                parseRealtimeData(rawData) {
                    // è§£æå®æ—¶æ•°æ®ï¼Œæå–é€Ÿåº¦å’Œæ•°æ®åŒ…ä¿¡æ¯
                    const receiveLine = rawData.find(line => line.includes('æ¥æ”¶'));
                    const sendLine = rawData.find(line => line.includes('å‘é€'));
                    
                    if (!receiveLine || !sendLine) {
                        if (this.debugMode) console.warn('å®æ—¶æ•°æ®è§£æå¤±è´¥ï¼šæœªæ‰¾åˆ°æ¥æ”¶æˆ–å‘é€è¡Œ', rawData);
                        return null;
                    }
                    // å¢å¼ºçš„æ­£åˆ™è¡¨è¾¾å¼ï¼Œæ”¯æŒå¤šç§æ ¼å¼
                    // æ ¼å¼1: 12345                   // æ ¼å¼2: 123.45 kb/s 1234 packets/s
                    const speedPattern = /(\d+\.?\d*)\s*([kmg]?b\/ç§’).*?(\d+)\s*(æ•°æ®åŒ…|packets|åŒ…|p)\/s/i;
                    // è§£ææ¥æ”¶æ•°æ®
                    const receiveMatch = receiveLine.match(speedPattern);
                    // è§£æå‘é€æ•°æ®
                    const sendMatch = sendLine.match(speedPattern);
                    if (!receiveMatch || !sendMatch) {
                        if (this.debugMode) console.warn('å®æ—¶æ•°æ®è§£æå¤±è´¥ï¼šæ­£åˆ™åŒ¹é…å¤±è´¥', {
                            receiveLine,
                            sendLine,
                            receiveMatch,
                            sendMatch
                        });
                        return null;
                    }
                    const now = new Date();
                    // ç»Ÿä¸€è½¬æ¢ä¸ºkb/s
                    const receiveSpeedKb = this.convertSpeedToUnit(parseFloat(receiveMatch[1]), receiveMatch[2]);
                    const sendSpeedKb = this.convertSpeedToUnit(parseFloat(sendMatch[1]), sendMatch[2]);
                    const parsedData = {
                        time: now.toLocaleTimeString(),
                        timestamp: now.getTime(),
                        receiveSpeed: receiveSpeedKb,
                        receiveSpeedUnit: 'kb/ç§’',
                        receivePackets: parseInt(receiveMatch[3]),
                        sendSpeed: sendSpeedKb,
                        sendSpeedUnit: 'kb/ç§’',
                        sendPackets: parseInt(sendMatch[3])
                    };
                    // éªŒè¯è§£æç»“æœ
                    if (isNaN(parsedData.receiveSpeed) || isNaN(parsedData.sendSpeed) || 
                        isNaN(parsedData.receivePackets) || isNaN(parsedData.sendPackets)) {
                        if (this.debugMode) console.warn('å®æ—¶æ•°æ®è§£æå¤±è´¥ï¼šæ•°å€¼è½¬æ¢å¤±è´¥', parsedData);
                        return null;
                    }
                    if (this.debugMode) console.log('å®æ—¶æ•°æ®è§£ææˆåŠŸ:', parsedData);
                    return parsedData;
                },
                renderRealtimeChart() {
                    this.safeRenderChart(() => {
                        const chartKey = '_realtimeChart';
                        if (this._realtimeChart) this._realtimeChart.destroy();
                        const ctx = this.$refs.realtimeChart;
                        if (!ctx) {
                            if (this.debugMode) console.warn('realtimeChart ref ä¸å­˜åœ¨');
                            throw new Error('realtimeChart ref ä¸å­˜åœ¨');
                        }
                        ctx.height = 200;
                        const parent = ctx.parentElement;
                        if (parent) ctx.width = parent.clientWidth;
                        const oneMinuteAgo = Date.now() - 1 * 60 * 1000;
                        const chartData = this.realtimeData.filter(item => item.timestamp >= oneMinuteAgo);
                        let labels, receiveSpeeds, sendSpeeds;
                        if (chartData.length === 0) {
                            if (this.debugMode) console.log('å®æ—¶å›¾è¡¨ï¼šä½¿ç”¨é»˜è®¤æ•°æ®');
                            const now = new Date();
                            labels = [now.toLocaleTimeString()];
                            receiveSpeeds = [0];
                            sendSpeeds = [0];
                        } else {
                            labels = chartData.map(item => item.time);
                            receiveSpeeds = chartData.map(item => item.receiveSpeed);
                            sendSpeeds = chartData.map(item => item.sendSpeed);
                        }
                        if (!labels.length) {
                            if (this.debugMode) console.warn('realtimeChart æ•°æ®ä¸ºç©º');
                            throw new Error('realtimeChart æ•°æ®ä¸ºç©º');
                        }
                        this._realtimeChart = new Chart(ctx, {
                            type: 'line',
                            data: {
                                labels,
                                datasets: [
                                    { label: 'æ¥æ”¶é€Ÿåº¦(kb/ç§’)', data: receiveSpeeds, borderColor: '#2563eb', backgroundColor: 'rgba(37,99,235,0.08)', tension: 0.3, fill: true },
                                    { label: 'å‘é€é€Ÿåº¦(kb/ç§’)', data: sendSpeeds, borderColor: '#fb923c', backgroundColor: 'rgba(251,146,60,0.08)', tension: 0.3, fill: true }
                                ]
                            },
                            options: {
                                responsive: true,
                                plugins: { 
                                    legend: { display: true }, 
                                    tooltip: { enabled: true } 
                                },
                                scales: { 
                                    y: { 
                                        beginAtZero: true, 
                                        title: { display: true, text: 'é€Ÿåº¦ (kb/ç§’)' } 
                                    } 
                                }
                            }
                        });
                    }, '_realtimeChart');
                },
                renderRealtimeTable() {
                    // ä¼˜åŒ–ï¼šä½¿ç”¨DocumentFragmentå‡å°‘DOMæ“ä½œ
                    const fragment = document.createDocumentFragment();
                    const container = document.createElement('div');
                    
                    // ç”Ÿæˆè¡¨æ ¼HTML
                    let html = `<div style='font-weight:bold;margin-bottom:4px;'>å®æ—¶æµé‡ç»Ÿè®¡</div>`;
                    if (this.realtimeData.length === 0) {
                        // æ˜¾ç¤ºåŸå§‹æ•°æ®ä½œä¸ºé™çº§æ–¹æ¡ˆ
                        html += `<div style="color:#666;font-style:italic;padding:10px;">æš‚æ— å®æ—¶æ•°æ®ï¼Œæ˜¾ç¤ºåŸå§‹æ•°æ®ï¼š</div>`;
                        if (this.realtimeStats.data && this.realtimeStats.data.length > 0) {
                            html += `<pre style="font-size:12px;background:#f8f9fa;padding:8px;border-radius:4px;">${this.realtimeStats.data.join('\n')}</pre>`;
                        } else {
                            html += `<div style="color:#999;text-align:center;padding:20px;">æš‚æ— æ•°æ®</div>`;
                        }
                    } else {
                        // ä¼˜åŒ–ï¼šä½¿ç”¨æ•°ç»„æ‹¼æ¥æ›¿ä»£å­—ç¬¦ä¸²æ‹¼æ¥
                        const tableParts = [];
                        tableParts.push('<table class="table table-sm table-bordered mb-0" style="font-size:13px;">');
                        tableParts.push('<thead><tr><th>æ—¶é—´</th><th>æ¥æ”¶é€Ÿåº¦(kb/ç§’)</th><th>æ¥æ”¶æ•°æ®åŒ…</th><th>å‘é€é€Ÿåº¦(kb/ç§’)</th><th>å‘é€æ•°æ®åŒ…</th></tr></thead>');
                        tableParts.push('<tbody>');
                        
                        // æ˜¾ç¤ºè§£æåçš„æ•°æ®è¡¨æ ¼
                        const tableData = this.realtimeData.slice(-8); // æœ€è¿‘8æ¡
                        const rowParts = [];
                        
                        tableData.forEach((item, index) => {
                            const isLatest = index === tableData.length - 1;
                            const rowBg = isLatest ? '#e3f2fd' : (index % 2 === 0 ? '#fff' : '#f6f8fa');
                            const textColor = isLatest ? '#1976d2' : '';
                            const style = `background:${rowBg};${textColor ? 'color: ' + textColor + ';font-weight:bold;' : ''}`;
                            
                            rowParts.push(`<tr style='${style}'>`);
                            rowParts.push(`<td>${item.time}</td>`);
                            rowParts.push(`<td style='color:#2563eb;font-weight:500;'>${item.receiveSpeed.toFixed(2)} kb/ç§’</td>`);
                            rowParts.push(`<td style='color:#2563eb;font-weight:500;'>${item.receivePackets} åŒ…/s</td>`);
                            rowParts.push(`<td style='color:#fb923c;font-weight:500;'>${item.sendSpeed.toFixed(2)} kb/ç§’</td>`);
                            rowParts.push(`<td style='color:#fb923c;font-weight:500;'>${item.sendPackets} åŒ…/s</td>`);
                            rowParts.push('</tr>');
                        });
                        
                        tableParts.push(rowParts.join(''));
                        tableParts.push('</tbody></table>');
                        html += tableParts.join('');
                    }
                    
                    container.innerHTML = html;
                    fragment.appendChild(container);
                    
                    // æ›´æ–°è¡¨æ ¼å†…å®¹
                    if (this.$refs.realtimeTable) {
                        this.$refs.realtimeTable.innerHTML = '';
                        this.$refs.realtimeTable.appendChild(fragment);
                    } else {
                        if (this.debugMode) console.warn('å®æ—¶è¡¨æ ¼æ¸²æŸ“å¤±è´¥ï¼šrealtimeTableå…ƒç´ ä¸å­˜åœ¨');
                    }
                },
                async loadMinuteStats() {
                    this.minuteStats.loading = true;
                    try {
                        const response = await axios.get(`/api/stats/${this.selectedInterface}/5`);
                        this.minuteStats.data = response.data.data.filter(line => line.trim());
                        this.$nextTick(() => this.renderMinuteChart());
                        // ç»Ÿä¸€å•ä½
                        const { labels, rx, tx } = this.parseStatData(this.minuteStats.data);
                        const all = rx.concat(tx);
                        const { unit, factor } = this.getBestUnitAndFactor(all);
                        this.minuteStats.unit = unit;
                        this.minuteStats.factor = factor;
                    } catch (error) {
                        this.minuteStats.data = ['é”™è¯¯: ' + (error.response?.data?.error || error.message)];
                    }
                    this.minuteStats.loading = false;
                },
                loadAllStats() {
                    this.loadRealtimeStats();
                    this.loadMinuteStats();
                    this.stats.forEach((stat, idx) => this.loadStats(stat, idx));
                    this.updateLastUpdateTime();
                    // æ–°å¢ï¼šåŠ è½½ç¼“å­˜å’Œç³»ç»ŸçŠ¶æ€
                    this.loadCacheStats();
                    this.loadSystemMemory();
                },
                updateLastUpdateTime() {
                    const now = new Date();
                    this.lastUpdateTime = now.toLocaleTimeString();
                },
                startAutoRefresh() {
                    // æ¸…ç†æ‰€æœ‰ç°æœ‰å®šæ—¶å™¨
                    this.clearAllIntervals();
                    
                    if (this.autoRefresh) {
                        // ä¼˜åŒ–ï¼šä½¿ç”¨å•ä¸ªå®šæ—¶å™¨ç®¡ç†æ‰€æœ‰åˆ·æ–°ä»»åŠ¡
                        this.refreshInterval = setInterval(() => {
                            const now = Date.now();
                            
                            // å®æ—¶æ•°æ®ï¼šæ¯ç§’æ›´æ–°
                            this.loadRealtimeStats();
                            this.updateLastUpdateTime();
                            
                            // åˆ†é’Ÿæ•°æ®ï¼šæ¯60ç§’æ›´æ–°
                            if (now % 60000 < 1000) {
                                this.loadMinuteStats();
                            }
                            
                            // ç»Ÿè®¡æ•°æ®ï¼šæ¯60ç§’æ›´æ–°
                            if (now % 60000 < 1000) {
                                this.stats.forEach((stat, idx) => this.loadStats(stat, idx));
                            }
                            
                            // ç¼“å­˜å’Œç³»ç»ŸçŠ¶æ€ï¼šæ¯30ç§’æ›´æ–°
                            if (now % 30000 < 1000) {
                                this.loadCacheStats();
                                this.loadSystemMemory();
                            }
                        }, 1000);
                    }
                },
                // æ–°å¢ï¼šæ¸…ç†æ‰€æœ‰å®šæ—¶å™¨
                clearAllIntervals() {
                    if (this.refreshInterval) {
                        clearInterval(this.refreshInterval);
                        this.refreshInterval = null;
                    }
                },
                async loadVersion() {
                    try {
                        const response = await axios.get('/api/version');
                        this.version = response.data.version;
                    } catch (error) {
                        console.error('è·å–ç‰ˆæœ¬å·å¤±è´¥:', error);
                    }
                },
                async queryDateRange() {
                    if (!this.isDateRangeValid) return;
                    
                    this.dateRangeStats.loading = true;
                    try {
                        const response = await axios.get(
                            `/api/stats/${this.selectedInterface}/range/${this.dateRange.start}/${this.dateRange.end}`
                        );
                        this.dateRangeStats.data = response.data.data;
                        
                        // å›ºå®šä½¿ç”¨GiBå•ä½ï¼Œå› å­ä¸º1/1024ï¼ˆä»MiBè½¬æ¢åˆ°GiBï¼‰
                        this.dateRangeStats.unit = 'GiB';
                        this.dateRangeStats.factor = 1/1024;
                        
                        // æ¸²æŸ“å›¾è¡¨
                        this.$nextTick(() => {
                            this.renderDateRangeChart();
                        });
                    } catch (error) {
                        this.error = 'æŸ¥è¯¢å¤±è´¥: ' + (error.response?.data?.error || error.message);
                    }
                    this.dateRangeStats.loading = false;
                },
                clearDateRangeStats() {
                    this.dateRangeStats.data = [];
                    this.dateRange.start = '';
                    this.dateRange.end = '';
                    // æ¸…ç†å›¾è¡¨å®ä¾‹
                    this.destroyChartInstance('dateRangeChart');
                },
                // æ–°ï¼šå°†æ ¼å¼åŒ–åçš„æ•°æ®æ¸²æŸ“ä¸ºHTMLè¡¨æ ¼
                renderTableHtml(data, unit) {
                    if (!data || data.length === 0) return '';
                    // ç¬¬ä¸€è¡Œä¸ºæ ‡é¢˜ï¼ˆå¦‚ eth0 / 5 minuteï¼‰ï¼Œå•ç‹¬ä¸€è¡Œ
                    let html = `<div style='font-weight:bold;margin-bottom:4px;'>${data[0]}</div>`;
                    // ç¬¬äºŒè¡Œä¸ºè¡¨å¤´ï¼Œä¸¥æ ¼ä¿è¯5åˆ—ï¼šå…ˆç”¨|åˆ†å‰²ï¼Œç¬¬ä¸€ä¸ªåˆ†æ®µå†ç”¨å¤šç©ºæ ¼åˆ†å‰²
                    let headerLine = data[1];
                    let header = [];
                    if (headerLine.includes('|')) {
                        const segs = headerLine.split('|');
                        header = segs[0].trim().split(/\s{2,}/).map(h => h.trim());
                        for (let i = 1; i < segs.length; i++) {
                            if (segs[i].trim()) header.push(segs[i].trim());
                        }
                    } else {
                        header = headerLine.split(/\s{2,}/).map(h => h.trim());
                    }
                    // è®°å½•å…³é”®åˆ—ç´¢å¼•
                    const rxIdx = header.findIndex(h => h.includes('æ¥æ”¶'));
                    const txIdx = header.findIndex(h => h.includes('å‘é€'));
                    const totalIdx = header.findIndex(h => h.includes('æ€»è®¡'));
                    const avgIdx = header.findIndex(h => h.includes('å¹³å‡é€Ÿç‡'));
                    html += '<table class="table table-sm table-bordered mb-0" style="font-size:13px;">';
                    html += '<thead><tr>' + header.map(h => `<th>${h}</th>`).join('') + '</tr></thead>';
                    html += '<tbody>';
                    // å…¶ä½™ä¸ºæ•°æ®è¡Œï¼Œåˆ†å‰²æ–¹å¼åŒä¸Š
                    let dataRowIdx = 0;
                    for (let i = 2; i < data.length; i++) {
                        let line = data[i];
                        if (line.includes('---')) continue;
                        let cols = [];
                        if (line.includes('|')) {
                            const segs = line.split('|');
                            cols = segs[0].trim().split(/\s{2,}/).map(c => c.trim());
                            for (let j = 1; j < segs.length; j++) {
                                if (segs[j].trim()) cols.push(segs[j].trim());
                            }
                        } else {
                            cols = line.split(/\s{2,}/).map(c => c.trim());
                        }
                        if (cols.length === 1 && !cols[0]) continue;
                        // æ–‘é©¬çº¹èƒŒæ™¯è‰²
                        const rowBg = dataRowIdx % 2 === 0 ? '#fff' : '#f6f8fa';
                        html += `<tr style='background:${rowBg};'>` +
                            cols.map((c, idx) => {
                                let style = '';
                                if (idx === rxIdx) style = 'color:#2563eb;font-weight:500;'; // ç°ä»£è“
                                if (idx === txIdx) style = 'color:#fb923c;font-weight:500;'; // ç°ä»£æ©™
                                if (idx === totalIdx) style = 'color:#14b8a6;font-weight:500;'; // ç°ä»£é’ç»¿
                                if (idx === avgIdx) style = 'color:#64748b;font-weight:500;'; // ç°ä»£è“ç°
                                return `<td style='${style}'>${c}</td>`;
                            }).join('') + '</tr>';
                        dataRowIdx++;
                    }
                    html += '</tbody></table>';
                    return html;
                },
                toggleTheme() {
                    this.isDarkMode = !this.isDarkMode;
                    document.body.classList.toggle('dark', this.isDarkMode);
                    localStorage.setItem('theme', this.isDarkMode ? 'dark' : 'light');
                },
                toggleDebugMode() {
                    this.debugMode = !this.debugMode;
                    localStorage.setItem('debugMode', this.debugMode);
                },
                applyThemeFromPreference() {
                    // ä¼˜å…ˆç”¨æˆ·é€‰æ‹©ï¼Œé»˜è®¤æµ…è‰²æ¨¡å¼
                    const userTheme = localStorage.getItem('theme');
                    if (userTheme === 'dark') {
                        this.isDarkMode = true;
                        document.body.classList.add('dark');
                    } else {
                        // é»˜è®¤æµ…è‰²æ¨¡å¼ï¼Œç§»é™¤ç³»ç»Ÿä¸»é¢˜è·Ÿéš
                        this.isDarkMode = false;
                        document.body.classList.remove('dark');
                    }
                    // åº”ç”¨è°ƒè¯•æ¨¡å¼ï¼Œé»˜è®¤å…³é—­
                    const userDebugMode = localStorage.getItem('debugMode');
                    this.debugMode = (userDebugMode === 'true');
                },
                // æ–°ï¼šé€Ÿåº¦å•ä½ç»Ÿä¸€è½¬æ¢ä¸ºkb/ç§’
                convertSpeedToUnit(speed, fromUnit) {
                    // å…ˆç»Ÿä¸€ä¸ºb/ç§’
                    let speedInBits = speed;
                    switch((fromUnit||'').toLowerCase()) {
                        case 'gb/ç§’':
                            speedInBits = speed * 1024;
                            break;
                        case 'mb/ç§’':
                            speedInBits = speed * 1024 * 1024;
                            break;
                        case 'kb/ç§’':
                            speedInBits = speed * 1024;
                            break;
                        case 'b/ç§’':
                        default:
                            speedInBits = speed;
                    }
                    // å†è½¬ä¸ºkb/ç§’
                    return speedInBits / 1024;
                },
                // æ–°å¢ï¼šæ™ºèƒ½é€‰æ‹©æœ€ä½³é€Ÿåº¦æ˜¾ç¤ºå•ä½
                getBestSpeedUnit(speeds) {
                    if (!speeds || speeds.length === 0) return 'b/s';
                    // æ‰¾åˆ°æœ€å¤§é€Ÿåº¦å€¼ï¼ˆå‡è®¾æ‰€æœ‰é€Ÿåº¦éƒ½å·²è½¬æ¢ä¸ºb/sï¼‰
                    const maxSpeed = Math.max(...speeds);
                    
                    if (maxSpeed >= 1024 * 1024 * 1024) return 'Gb/s';
                    if (maxSpeed >= 1024 * 1024) return 'Mb/s';
                    if (maxSpeed >= 1024) return 'Kb/s';
                    return 'b/s';
                },
                // æ–°å¢ï¼šè·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
                async loadCacheStats() {
                    try {
                        const response = await axios.get('/api/cache/stats');
                        this.cacheStats = response.data;
                    } catch (error) {
                        console.error('è·å–ç¼“å­˜ç»Ÿè®¡å¤±è´¥:', error);
                    }
                },
                // æ–°å¢ï¼šè·å–ç³»ç»Ÿå†…å­˜ä¿¡æ¯
                async loadSystemMemory() {
                    try {
                        const response = await axios.get('/api/system/memory');
                        this.systemMemory = response.data;
                    } catch (error) {
                        console.error('è·å–ç³»ç»Ÿå†…å­˜ä¿¡æ¯å¤±è´¥:', error);
                    }
                },
                // æ–°å¢ï¼šæ¸…ç©ºç¼“å­˜
                async clearCache() {
                    try {
                        await axios.post('/api/cache/clear');
                        this.loadCacheStats(); // é‡æ–°åŠ è½½ç»Ÿè®¡ä¿¡æ¯
                        console.log('ç¼“å­˜å·²æ¸…ç©º');
                    } catch (error) {
                        console.error('æ¸…ç©ºç¼“å­˜å¤±è´¥:', error);
                    }
                },
                // æ–°å¢ï¼šæ€§èƒ½ç›‘æ§åŒ…è£…å™¨
                async measurePerformance(apiCall) {
                    const startTime = Date.now();
                    try {
                        const result = await apiCall();
                        const responseTime = Date.now() - startTime;
                        
                        // æ›´æ–°æ€§èƒ½ç»Ÿè®¡
                        this.performance.lastResponseTime = responseTime;
                        this.performance.requestCount++;
                        this.performance.averageResponseTime = 
                            (this.performance.averageResponseTime * (this.performance.requestCount - 1) + responseTime) / this.performance.requestCount;
                        
                        return result;
                    } catch (error) {
                        const responseTime = Date.now() - startTime;
                        this.performance.lastResponseTime = responseTime;
                        throw error;
                    }
                },
                // æ–°å¢ï¼šæ£€æŸ¥æœåŠ¡å™¨çŠ¶æ€
                async checkServerStatus() {
                    try {
                        const response = await axios.get('/api/system/status');
                        return {
                            success: true,
                            data: response.data
                        };
                    } catch (error) {
                        return {
                            success: false,
                            error: error.response?.data?.error || error.message,
                            status: error.response?.status
                        };
                    }
                },
                // æ–°å¢ï¼šæµ‹è¯•vnstatå‘½ä»¤
                async testVnstat() {
                    try {
                        const response = await axios.get('/api/test/vnstat');
                        return {
                            success: true,
                            data: response.data
                        };
                    } catch (error) {
                        return {
                            success: false,
                            error: error.response?.data?.error || error.message
                        };
                    }
                },
                // æ–°å¢ï¼šè¯Šæ–­è¿æ¥é—®é¢˜
                async diagnoseConnection() {
                    const diagnosis = {
                        timestamp: new Date().toISOString(),
                        serverStatus: null,
                        vnstatTest: null,
                        recommendations: []
                    };

                    // æ£€æŸ¥æœåŠ¡å™¨çŠ¶æ€
                    const serverStatus = await this.checkServerStatus();
                    diagnosis.serverStatus = serverStatus;

                    if (!serverStatus.success) {
                        diagnosis.recommendations.push('æœåŠ¡å™¨è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨æ˜¯å¦æ­£åœ¨è¿è¡Œ');
                        if (serverStatus.status === 503) {
                            diagnosis.recommendations.push('æœåŠ¡å™¨è¿”å›503é”™è¯¯ï¼Œå¯èƒ½æ˜¯vnstatå‘½ä»¤æœªå®‰è£…æˆ–é…ç½®é”™è¯¯');
                        }
                    } else {
                        // å¦‚æœæœåŠ¡å™¨è¿æ¥æˆåŠŸï¼Œæµ‹è¯•vnstat
                        const vnstatTest = await this.testVnstat();
                        diagnosis.vnstatTest = vnstatTest;

                        if (!vnstatTest.success) {
                            diagnosis.recommendations.push('vnstatå‘½ä»¤æµ‹è¯•å¤±è´¥ï¼Œè¯·æ£€æŸ¥vnstatæ˜¯å¦æ­£ç¡®å®‰è£…');
                        } else if (!serverStatus.data.vnstat.available) {
                            diagnosis.recommendations.push('vnstatå‘½ä»¤ä¸å¯ç”¨ï¼Œè¯·æ£€æŸ¥ç³»ç»Ÿé…ç½®');
                        }
                    }

                    return diagnosis;
                },
                // æ–°å¢ï¼šè¿è¡Œè¯Šæ–­
                async runDiagnosis() {
                    this.diagnosisResult = await this.diagnoseConnection();
                },
                // æ–°å¢ï¼šChart.jså®ä¾‹ç®¡ç†
                getChartInstance(key) {
                    return this.chartInstances.get(key);
                },
                setChartInstance(key, instance) {
                    // æ¸…ç†æ—§å®ä¾‹
                    const oldInstance = this.chartInstances.get(key);
                    if (oldInstance) {
                        oldInstance.destroy();
                    }
                    this.chartInstances.set(key, instance);
                },
                destroyChartInstance(key) {
                    const instance = this.chartInstances.get(key);
                    if (instance) {
                        instance.destroy();
                        this.chartInstances.delete(key);
                    }
                },
                // æ–°å¢ï¼šèŠ‚æµå‡½æ•°
                throttle(func, delay) {
                    let lastCall = 0;
                    return function(...args) {
                        const now = Date.now();
                        if (now - lastCall >= delay) {
                            lastCall = now;
                            return func.apply(this, args);
                        }
                    };
                },
                // æ–°å¢ï¼šé˜²æŠ–å‡½æ•°
                debounce(func, delay) {
                    let timeoutId;
                    return function(...args) {
                        clearTimeout(timeoutId);
                        timeoutId = setTimeout(() => func.apply(this, args), delay);
                    };
                },
                // æ–°å¢ï¼šæ‰¹é‡æ›´æ–°å›¾è¡¨
                async batchUpdateCharts() {
                    if (this.isUpdating) return;
                    
                    this.isUpdating = true;
                    const now = Date.now();
                    
                    // æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°
                    if (now - this.lastChartUpdate < this.chartUpdateThrottle) {
                        this.isUpdating = false;
                        return;
                    }
                    
                    try {
                        // æ‰¹é‡æ›´æ–°æ‰€æœ‰å¾…æ›´æ–°çš„å›¾è¡¨
                        for (const updateFunc of this.updateQueue) {
                            await updateFunc();
                        }
                        this.updateQueue.clear();
                        this.lastChartUpdate = now;
                    } finally {
                        this.isUpdating = false;
                    }
                },
                // æ–°å¢ï¼šæ¸²æŸ“æŒ‡å®šæ—¥æœŸæŸ¥è¯¢ç»“æœå›¾è¡¨
                renderDateRangeChart() {
                    this.safeRenderChart(() => {
                        const chartKey = 'dateRangeChart';
                        const existingChart = this.getChartInstance(chartKey);
                        if (existingChart) existingChart.destroy();
                        const ctx = this.$refs.dateRangeChart;
                        if (!ctx) {
                            if (this.debugMode) console.warn('dateRangeChart ref ä¸å­˜åœ¨');
                            throw new Error('dateRangeChart ref ä¸å­˜åœ¨');
                        }
                        ctx.height = 180;
                        const parent = ctx.parentElement;
                        if (parent) ctx.width = parent.clientWidth;
                        const { labels, rx, tx } = this.parseStatData(this.dateRangeStats.data, this.dateRangeStats.unit);
                        if (!labels.length) {
                            if (this.debugMode) console.warn('dateRangeChart æ•°æ®ä¸ºç©º');
                            throw new Error('dateRangeChart æ•°æ®ä¸ºç©º');
                        }
                        const chart = new Chart(ctx, {
                            type: 'line',
                            data: {
                                labels,
                                datasets: [
                                    { label: `æ¥æ”¶(${this.dateRangeStats.unit})`, data: rx, borderColor: '#2563eb', backgroundColor: 'rgba(37,99,235,0.08)', tension: 0.3, fill: true },
                                    { label: `å‘é€(${this.dateRangeStats.unit})`, data: tx, borderColor: '#fb923c', backgroundColor: 'rgba(251,146,60,0.08)', tension: 0.3, fill: true }
                                ]
                            },
                            options: {
                                responsive: true,
                                plugins: { legend: { display: true }, tooltip: { enabled: true } },
                                scales: { y: { beginAtZero: true, title: { display: true, text: this.dateRangeStats.unit } } }
                            }
                        });
                        this.setChartInstance(chartKey, chart);
                    }, 'dateRangeChart');
                },
                // æ–°å¢ï¼šæ·»åŠ å›¾è¡¨æ›´æ–°åˆ°é˜Ÿåˆ—
                queueChartUpdate(updateFunc) {
                    this.updateQueue.add(updateFunc);
                    // ä½¿ç”¨é˜²æŠ–æ¥æ‰¹é‡æ›´æ–°
                    this.debouncedBatchUpdate();
                }
            },
            watch: {
                autoRefresh(newValue) {
                    if (newValue) {
                        this.startAutoRefresh();
                    } else {
                        this.clearAllIntervals();
                    }
                }
            },
            mounted() {
                // åˆå§‹åŒ–é˜²æŠ–å‡½æ•°
                this.debouncedBatchUpdate = this.debounce(this.batchUpdateCharts, 50);
                
                this.loadInterfaces();
                this.startAutoRefresh();
                this.loadVersion();
                this.applyThemeFromPreference();
                // æ–°å¢ï¼šç›‘å¬çª—å£resizeäº‹ä»¶
                window.addEventListener('resize', this.throttle(this.resizeAllCharts, 250));
                
                // æµ‹è¯•å®æ—¶ç»Ÿè®¡åŠŸèƒ½
                if (this.debugMode) {
                    console.log('FlowMaster å®æ—¶ç»Ÿè®¡åŠŸèƒ½æµ‹è¯•å¼€å§‹...');
                    // æ¨¡æ‹Ÿæµ‹è¯•æ•°æ®
                    setTimeout(() => {
                        if (this.realtimeData.length === 0) {
                            console.warn('æµ‹è¯•ï¼šå®æ—¶æ•°æ®ä¸ºç©ºï¼Œé™çº§æ˜¾ç¤ºæœºåˆ¶åº”è¯¥ç”Ÿæ•ˆ');
                        } else {
                            console.log('æµ‹è¯•ï¼šå®æ—¶æ•°æ®æ­£å¸¸ï¼Œå…±', this.realtimeData.length, 'æ¡è®°å½•');
                        }
                    }, 3000);
                }
            },
            beforeUnmount() {
                // æ¸…ç†æ‰€æœ‰å®šæ—¶å™¨
                this.clearAllIntervals();
                
                // æ¸…ç†æ‰€æœ‰Chart.jså®ä¾‹
                this.chartInstances.forEach((instance, key) => {
                    if (instance && typeof instance.destroy === 'function') {
                        instance.destroy();
                    }
                });
                this.chartInstances.clear();
                
                // æ¸…ç†æ›´æ–°é˜Ÿåˆ—
                this.updateQueue.clear();
                
                // æ¸…ç†æ•°æ®ç¼“å­˜
                this.realtimeData = [];
                this.cacheStats = null;
                this.systemMemory = null;
                this.performance = null;
                this.diagnosisResult = null;
                
                // ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
                window.removeEventListener('resize', this.throttle(this.resizeAllCharts, 250));
                
                // æ¸…ç†DOMå¼•ç”¨
                this.$refs = {};
            }
        });

        app.mount('#app');
        
        // æ–°å¢ï¼šæ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–æç¤º
        window.performanceMark('app-mounted');
        
        // è®°å½•åº”ç”¨åŠ è½½å®Œæˆæ—¶é—´
        if (window.performance && window.performance.measure) {
            window.performance.measure('app-load-time', 'app-start', 'app-mounted');
            const measure = window.performance.getEntriesByName('app-load-time')[0];
            console.log(`åº”ç”¨åŠ è½½å®Œæˆï¼Œè€—æ—¶: ${measure.duration.toFixed(2)}ms`);
        }
        
        // æ€§èƒ½ä¼˜åŒ–æç¤º
        console.log('FlowMaster æ€§èƒ½ä¼˜åŒ–å·²å¯ç”¨:');
        console.log('- Chart.jså®ä¾‹æ± ç®¡ç†');
        console.log('- é˜²æŠ–å’ŒèŠ‚æµæœºåˆ¶');
        console.log('- æ‰¹é‡DOMæ›´æ–°');
        console.log('- æ™ºèƒ½å®šæ—¶å™¨ç®¡ç†');
        console.log('- å†…å­˜è‡ªåŠ¨æ¸…ç†');
    </script>

    <!-- 51.la ç»Ÿè®¡ä»£ç  -->
    <script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
    <script>LA.init({id:"24WADmnDKAw7Dh8r",ck:"24WADmnDKAw7Dh8r"})</script>

</body>
</html> 