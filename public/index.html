<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- æ·»åŠ ç½‘ç«™å›¾æ ‡ -->
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="apple-touch-icon" href="favicon.png">
    
    <!-- SEO Meta æ ‡ç­¾ -->
    <title>FlowMaster | ä¸“ä¸šçš„ç½‘ç»œæµé‡å®æ—¶ç›‘æ§ç³»ç»Ÿ</title>
    <meta name="description" content="FlowMasteræ˜¯ä¸€æ¬¾ä¸“ä¸šçš„ç½‘ç»œæµé‡ç›‘æ§ç³»ç»Ÿï¼Œæä¾›å®æ—¶æµé‡ç»Ÿè®¡ã€å†å²æ•°æ®æŸ¥è¯¢ã€å¤šæ¥å£æ”¯æŒç­‰åŠŸèƒ½ï¼Œå¸®åŠ©æ‚¨æ›´å¥½åœ°ç®¡ç†å’Œåˆ†æç½‘ç»œæµé‡ã€‚">
    <meta name="keywords" content="FlowMaster,æµé‡ç›‘æ§,ç½‘ç»œç›‘æ§,æµé‡ç»Ÿè®¡,ç½‘ç»œæµé‡åˆ†æ,å®æ—¶ç›‘æ§">
    <meta name="author" content="vbskycn">
    
    <!-- Open Graph Meta æ ‡ç­¾ (ç”¨äºç¤¾äº¤åª’ä½“åˆ†äº«) -->
    <meta property="og:title" content="FlowMaster | ä¸“ä¸šçš„ç½‘ç»œæµé‡å®æ—¶ç›‘æ§ç³»ç»Ÿ">
    <meta property="og:description" content="ä¸“ä¸šçš„ç½‘ç»œæµé‡ç›‘æ§ç³»ç»Ÿï¼Œæä¾›å®æ—¶æµé‡ç»Ÿè®¡ã€å†å²æ•°æ®æŸ¥è¯¢ã€å¤šæ¥å£æ”¯æŒç­‰åŠŸèƒ½ã€‚">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://github.com/vbskycn/FlowMaster">
    
    <!-- Twitter Card Meta æ ‡ç­¾ -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="FlowMaster | ä¸“ä¸šçš„ç½‘ç»œæµé‡å®æ—¶ç›‘æ§ç³»ç»Ÿ">
    <meta name="twitter:description" content="ä¸“ä¸šçš„ç½‘ç»œæµé‡ç›‘æ§ç³»ç»Ÿï¼Œæä¾›å®æ—¶æµé‡ç»Ÿè®¡ã€å†å²æ•°æ®æŸ¥è¯¢ã€å¤šæ¥å£æ”¯æŒç­‰åŠŸèƒ½ã€‚">
    
    <!-- ç§»åŠ¨è®¾å¤‡ä¼˜åŒ– -->
    <meta name="theme-color" content="#4a90e2">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <!-- æœç´¢å¼•æ“æŒ‡ä»¤ -->
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://github.com/vbskycn/FlowMaster">

    <!-- ç»“æ„åŒ–æ•°æ® (JSON-LD) -->
    <script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "SoftwareApplication",
        "name": "FlowMaster",
        "description": "ä¸“ä¸šçš„ç½‘ç»œæµé‡å®æ—¶ç›‘æ§ç³»ç»Ÿï¼Œæä¾›å®æ—¶æµé‡ç»Ÿè®¡ã€å†å²æ•°æ®æŸ¥è¯¢ã€å¤šæ¥å£æ”¯æŒç­‰åŠŸèƒ½ã€‚",
        "applicationCategory": "NetworkMonitoringTool",
        "operatingSystem": "All",
        "author": {
            "@type": "Person",
            "name": "vbskycn",
            "url": "https://github.com/vbskycn"
        },
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        }
    }
    </script>

    <link href="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/twitter-bootstrap/5.1.3/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.bootcdn.net/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script>
    <script src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/vue/3.2.31/vue.global.min.js"></script>
    <script src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/axios/0.26.0/axios.min.js"></script>
    <link href="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/bootstrap-icons/1.8.0/font/bootstrap-icons.min.css" rel="stylesheet">
    <link href="/css/main.css" rel="stylesheet">
    <link href="/css/dark-theme.css" rel="stylesheet">
</head>
<body>
    <header class="container py-4">
        <div id="app">
            <div class="d-flex justify-content-between align-items-center mb-3">
                <div class="d-flex align-items-center">
                    <h1 class="mb-0">FlowMaster æµé‡ç›‘æ§</h1>
                    <span class="version-badge ms-3" v-cloak>v{{version}}</span>
                </div>
                <div class="refresh-control text-end">
                    <div class="form-check form-switch d-inline-block">
                        <input class="form-check-input" type="checkbox" v-model="autoRefresh" id="autoRefreshSwitch">
                        <label class="form-check-label" for="autoRefreshSwitch">
                            è‡ªåŠ¨åˆ·æ–°
                        </label>
                    </div>
                    <!-- ä¸»é¢˜åˆ‡æ¢å¼€å…³ -->
                    <button class="btn btn-sm ms-2" :class="isDarkMode ? 'btn-dark' : 'btn-light'" @click="toggleTheme" :aria-label="isDarkMode ? 'åˆ‡æ¢ä¸ºæµ…è‰²' : 'åˆ‡æ¢ä¸ºæ·±è‰²'" style="vertical-align:middle;">
                        <span v-if="isDarkMode">ğŸŒ™</span>
                        <span v-else>â˜€ï¸</span>
                    </button>
                    <!-- è°ƒè¯•æ¨¡å¼æŒ‰é’®å·²ç§»é™¤ -->
                    <div class="update-time" v-if="lastUpdateTime">
                        æœ€åæ›´æ–°: {{lastUpdateTime}}
                    </div>
                </div>
            </div>

            <div v-if="error" class="alert alert-danger" v-cloak>
                {{error}}
            </div>

            <div class="row align-items-center mb-3">
                <div class="col-md-4">
                    <select v-model="selectedInterface" class="form-select" @change="loadAllStats" v-cloak>
                        <option v-for="interface in interfaces" :key="interface" :value="interface">
                            {{interface}}
                        </option>
                    </select>
                </div>
                <div class="col-md-8">
                    <p class="text-muted mb-0 mt-2 mt-md-0" v-cloak>
                        å½“å‰é€‰æ‹©çš„ç½‘ç»œæ¥å£: {{selectedInterface}}
                    </p>
                </div>
            </div>

            <div class="card mb-3" v-cloak>
                <div class="card-body py-2">
                    <div class="row g-2 align-items-end">
                        <div class="col-md-3">
                            <label for="startDate" class="form-label small mb-1">å¼€å§‹æ—¥æœŸ</label>
                            <input type="date" class="form-control form-control-sm" id="startDate" v-model="dateRange.start">
                        </div>
                        <div class="col-md-3">
                            <label for="endDate" class="form-label small mb-1">ç»“æŸæ—¥æœŸ</label>
                            <input type="date" class="form-control form-control-sm" id="endDate" v-model="dateRange.end">
                        </div>
                        <div class="col-md-2">
                            <button type="button" class="btn btn-primary btn-sm w-100" @click="queryDateRange" :disabled="!isDateRangeValid">
                                æŸ¥è¯¢
                            </button>
                        </div>
                        <div class="col-md-2" v-if="dateRangeStats.data.length">
                            <button type="button" class="btn btn-outline-secondary btn-sm w-100" @click="clearDateRangeStats">
                                æ¸…é™¤
                            </button>
                        </div>
                    </div>
                    
                    <!-- æŸ¥è¯¢ç»“æœæ˜¾ç¤º -->
                    <div v-if="dateRangeStats.data.length" class="mt-2">
                        <pre class="mb-0 small">{{dateRangeStats.data.join('\n')}}</pre>
                    </div>
                </div>
            </div>

            <div class="row" v-cloak>
                <div class="col-md-12 mb-4">
                    <div class="card" :class="{ loading: realtimeStats.loading }">
                        <div class="card-header">
                            <h5 class="card-title mb-0">å®æ—¶ç»Ÿè®¡</h5>
                        </div>
                        <div class="card-body">
                            <!-- å®æ—¶æµé‡å›¾è¡¨ -->
                            <div class="chart-container" style="height:200px;margin-bottom:15px;">
                                <canvas ref="realtimeChart" style="width:100%;height:100%;"></canvas>
                            </div>
                            <!-- å®æ—¶æµé‡è¡¨æ ¼ -->
                            <div ref="realtimeTable" style="max-height:300px;overflow-y:auto;"></div>
                        </div>
                    </div>
                </div>

                <div class="col-md-12 mb-4">
                    <div class="card" :class="{ loading: minuteStats.loading }">
                        <div class="card-header">
                            <h5 class="card-title mb-0">åˆ†é’Ÿç»Ÿè®¡</h5>
                        </div>
                        <div class="card-body">
                            <div class="chart-container" style="height:180px;">
                                <canvas ref="minuteChart" style="width:100%;height:100%;"></canvas>
                            </div>
                            <div v-html="renderTableHtml(formatTableDataUnified(minuteStats.data, minuteStats.unit, minuteStats.factor), minuteStats.unit)"></div>
                        </div>
                    </div>
                </div>

                <div class="col-md-6 mb-4" v-for="(stat, index) in stats" :key="index">
                    <div class="card" :class="{ loading: stat.loading }">
                        <div class="card-header">
                            <h5 class="card-title mb-0">{{stat.title}}</h5>
                        </div>
                        <div class="card-body">
                            <div class="chart-container" style="height:180px;">
                                <canvas :ref="'statChart' + index" style="width:100%;height:100%;"></canvas>
                            </div>
                            <div v-html="renderTableHtml(formatTableDataUnified(stat.data, stat.unit, stat.factor), stat.unit)"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <main role="main">
        <!-- ... åŸæœ‰çš„ä¸»è¦å†…å®¹ ... -->
    </main>

    <footer class="footer" role="contentinfo">
        <div class="container">
            <div class="footer-content">
                <div class="footer-brand">
                    <span class="footer-text">FlowMaster</span>
                    <span class="version-badge ms-2" v-cloak>v{{version}}</span>
                    <span class="copyright-text ms-3">Â© 2025 by 
                        <a href="https://www.zhoujie218.top" target="_blank" class="author-link">zhoujie218</a>
                    </span>
                </div>
                <a href="https://github.com/vbskycn/FlowMaster" target="_blank" class="github-link">
                    <i class="bi bi-github"></i> GitHub
                </a>
            </div>
        </div>
    </footer>

    <!-- ä½¿ç”¨ç¨³å®šç‰ˆæœ¬çš„ Bootstrap Icons CDN -->
    

    <!-- Chart.js CDN -->
    

    <!-- æ›´æ–°é¡µè„šæ ·å¼ -->
    <!-- å·²åˆ†ç¦»è‡³main.csså’Œdark-theme.cssï¼Œæ— éœ€ä¿ç•™å†…è”æ ·å¼ -->

    <script>
        const app = Vue.createApp({
            data() {
                return {
                    interfaces: [],
                    selectedInterface: 'eth0',
                    error: null,
                    realtimeStats: { data: [], loading: false },
                    minuteStats: { data: [], loading: false },
                    stats: [
                        { period: 'h', title: 'å°æ—¶ç»Ÿè®¡', data: [], loading: false },
                        { period: 'd', title: 'æ—¥ç»Ÿè®¡', data: [], loading: false },
                        { period: 'm', title: 'æœˆç»Ÿè®¡', data: [], loading: false },
                        { period: 'y', title: 'å¹´ç»Ÿè®¡', data: [], loading: false }
                    ],
                    autoRefresh: false,
                    refreshInterval: null,
                    lastUpdateTime: '',
                    version: '',
                    dateRange: {
                        start: '',
                        end: ''
                    },
                    dateRangeStats: {
                        data: [],
                        loading: false
                    },
                    isDarkMode: false,
                    realtimeData: [], // å­˜å‚¨æœ€è¿‘20æ¡å®æ—¶æ•°æ®è®°å½•
                    debugMode: false // è°ƒè¯•æ¨¡å¼å¼€å…³
                }
            },
            computed: {
                isDateRangeValid() {
                    return this.dateRange.start && this.dateRange.end && 
                           this.dateRange.start <= this.dateRange.end;
                }
            },
            methods: {
                async loadInterfaces() {
                    try {
                        const response = await axios.get('/api/interfaces');
                        // å¯¹æ¥å£åˆ—è¡¨è¿›è¡Œæ’åº
                        this.interfaces = response.data.interfaces.sort((a, b) => {
                            // å®šä¹‰æ¥å£ä¼˜å…ˆçº§å‡½æ•°
                            const getPriority = (name) => {
                                // å¸¸è§ç‰©ç†ç½‘å¡æ¥å£ä¼˜å…ˆ
                                if (name.startsWith('eth')) return 1;
                                if (name.startsWith('ens')) return 2;
                                if (name.startsWith('enp')) return 3;
                                // å…¶ä»–å¸¸è§ç½‘å¡æ¥å£
                                if (name.startsWith('wlan')) return 10;
                                if (name.startsWith('bond')) return 11;
                                if (name.startsWith('br-')) return 12;
                                // è™šæ‹Ÿå’Œå®¹å™¨æ¥å£é å
                                if (name.startsWith('docker')) return 100;
                                if (name.includes('veth') || 
                                    name.includes('virbr') || 
                                    name.includes('tun') || 
                                    name.includes('tap')) return 101;
                                return 50; // å…¶ä»–æ¥å£
                            };
                            
                            const priorityA = getPriority(a);
                            const priorityB = getPriority(b);
                            
                            // é¦–å…ˆæŒ‰ä¼˜å…ˆçº§æ’åº
                            if (priorityA !== priorityB) {
                                return priorityA - priorityB;
                            }
                            
                            // ä¼˜å…ˆçº§ç›¸åŒæ—¶æŒ‰å­—æ¯é¡ºåºæ’åº
                            return a.localeCompare(b);
                        });

                        // é€‰æ‹©ç¬¬ä¸€ä¸ªæ¥å£ä½œä¸ºé»˜è®¤å€¼
                        if (this.interfaces.length > 0) {
                            this.selectedInterface = this.interfaces[0];
                            this.loadAllStats();
                        }
                    } catch (error) {
                        this.error = 'æ— æ³•è·å–ç½‘ç»œæ¥å£åˆ—è¡¨: ' + (error.response?.data?.error || error.message);
                    }
                },
                parseStatData(data, unit = 'MiB') {
                    // è§£æstat.dataï¼Œè¿”å› { labels: [], rx: [], tx: [] }
                    let labels = [];
                    let rx = [];
                    let tx = [];
                    let headerIdx = -1;
                    let rxIdx = -1, txIdx = -1, labelIdx = 0;
                    let started = false;
                    for (let i = 0; i < data.length; i++) {
                        const line = data[i].trim();
                        if (!line) continue;
                        if (line.includes('---')) { started = true; continue; }
                        if (!started) {
                            // è¯†åˆ«è¡¨å¤´
                            headerIdx = i;
                            const header = data[i].replace(/\s+/g, ' ').trim().split(' ');
                            rxIdx = header.findIndex(h => h.startsWith('æ¥æ”¶'));
                            txIdx = header.findIndex(h => h.startsWith('å‘é€'));
                            labelIdx = 0; // é€šå¸¸ç¬¬ä¸€ä¸ªæ˜¯æ—¶é—´/æ—¥æœŸ
                            continue;
                        }
                        // è§£ææ•°æ®è¡Œ
                        const cols = line.replace(/\s+/g, ' ').trim().split(' ');
                        if (cols.length < Math.max(rxIdx, txIdx) + 1) continue;
                        // è·³è¿‡åˆè®¡/å¹³å‡/é¢„è®¡ç­‰è¡Œ
                        if (/æ€»è®¡|å¹³å‡|é¢„è®¡|total|avg|est/.test(cols[labelIdx])) continue;
                        labels.push(cols[labelIdx]);
                        rx.push(this.extractPureNumber(cols[rxIdx]));
                        tx.push(this.extractPureNumber(cols[txIdx]));
                    }
                    return { labels, rx, tx };
                },
                extractPureNumber(val) {
                    // åªæå–æ•°å€¼éƒ¨åˆ†ï¼Œä¸åšå•ä½æ¢ç®—
                    if (!val) return 0;
                    const match = val.match(/([\d.]+)/);
                    if (!match) return 0;
                    return parseFloat(match[1]);
                },
                getBestUnitAndFactor(arr) {
                    // è®¡ç®—æœ€ä½³å•ä½å’Œæ¢ç®—å› å­ï¼Œæ”¯æŒMiB/GiB/TiB
                    const max = Math.max(...arr);
                    if (max >= 1024 * 1024) return { unit: 'TiB', factor: 1 / (1024 * 1024) };
                    if (max >= 1024) return { unit: 'GiB', factor: 1 / 1024 };
                    return { unit: 'MiB', factor: 1 };
                },
                // æ–°ï¼šæ ¼å¼åŒ–è¡¨æ ¼æ•°æ®ä¸ºç»Ÿä¸€å•ä½ä¸”ç§»é™¤åŸå§‹å•ä½
                formatTableDataUnified(data, unit, factor) {
                    let result = [];
                    let started = false;
                    let rxIdx = -1, txIdx = -1, totalIdx = -1;
                    for (let i = 0; i < data.length; i++) {
                        let line = data[i];
                        if (!started && line.includes('---')) { started = true; result.push(line); continue; }
                        if (!started) {
                            // å¤„ç†è¡¨å¤´ï¼Œæ ‡æ³¨å•ä½
                            let header = line.replace(/\s+/g, ' ').trim().split(' ');
                            rxIdx = header.findIndex(h => h === 'æ¥æ”¶' || h.toLowerCase() === 'rx');
                            txIdx = header.findIndex(h => h === 'å‘é€' || h.toLowerCase() === 'tx');
                            totalIdx = header.findIndex(h => h === 'æ€»è®¡' || h.toLowerCase() === 'total');
                            if (rxIdx !== -1) header[rxIdx] += `(${unit})`;
                            if (txIdx !== -1) header[txIdx] += `(${unit})`;
                            if (totalIdx !== -1) header[totalIdx] += `(${unit})`;
                            result.push(header.join(' '));
                            continue;
                        }
                        // åªå¤„ç†æ•°æ®è¡Œ
                        let cols = line.replace(/\s+/g, ' ').trim().split(' ');
                        if (cols.length < Math.max(rxIdx, txIdx, totalIdx) + 1) { result.push(line); continue; }
                        // è·³è¿‡åˆè®¡/å¹³å‡/é¢„è®¡ç­‰è¡Œ
                        if (/æ€»è®¡|å¹³å‡|é¢„è®¡|total|avg|est/.test(cols[0])) { result.push(line); continue; }
                        // æ ¼å¼åŒ–æ•°å€¼å¹¶ç§»é™¤åŸå•ä½
                        if (rxIdx !== -1) cols[rxIdx] = this.formatValueToUnitNoUnit(cols[rxIdx], factor);
                        if (txIdx !== -1) cols[txIdx] = this.formatValueToUnitNoUnit(cols[txIdx], factor);
                        if (totalIdx !== -1) cols[totalIdx] = this.formatValueToUnitNoUnit(cols[totalIdx], factor);
                        result.push(cols.join(' '));
                    }
                    return result;
                },
                formatValueToUnitNoUnit(val, factor) {
                    // æå–æ•°å€¼å¹¶æ¢ç®—ä¸ºç›®æ ‡å•ä½ï¼Œä¿ç•™ä¸¤ä½å°æ•°ï¼Œä¸æ˜¾ç¤ºåŸå•ä½
                    const match = val.match(/([\d.]+)/);
                    if (!match) return val;
                    let num = parseFloat(match[1]);
                    if (isNaN(num)) return val;
                    return (num * factor).toFixed(2);
                },
                renderMinuteChart() {
                    if (this._minuteChart) this._minuteChart.destroy();
                    const ctx = this.$refs.minuteChart;
                    // ä¿®å¤è‡ªåŠ¨åˆ·æ–°å¯¼è‡´canvasé«˜åº¦å¼‚å¸¸
                    if (ctx) {
                        ctx.height = 180;
                        // æ–°å¢ï¼šåŠ¨æ€è®¾ç½®canvaså®½åº¦ä¸ºçˆ¶å®¹å™¨å®½åº¦
                        const parent = ctx.parentElement;
                        if (parent) {
                            ctx.width = parent.clientWidth;
                        }
                    }
                    // 5åˆ†é’Ÿå¡ç‰‡å•ä½å›ºå®šä¸ºMiB
                    const unit = 'MiB';
                    const { labels, rx, tx } = this.parseStatData(this.minuteStats.data, unit);
                    if (!labels.length) return;
                    this._minuteChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels,
                            datasets: [
                                { label: `æ¥æ”¶(${unit})`, data: rx, borderColor: '#2563eb', backgroundColor: 'rgba(37,99,235,0.08)', tension: 0.3, fill: true },
                                { label: `å‘é€(${unit})`, data: tx, borderColor: '#fb923c', backgroundColor: 'rgba(251,146,60,0.08)', tension: 0.3, fill: true }
                            ]
                        },
                        options: {
                            responsive: true,
                            plugins: { legend: { display: true }, tooltip: { enabled: true } },
                            scales: { y: { beginAtZero: true, title: { display: true, text: unit } } }
                        }
                    });
                },
                renderStatChart(index) {
                    if (!this._statCharts) this._statCharts = [];
                    if (this._statCharts[index]) this._statCharts[index].destroy();
                    // å…¼å®¹refä¸ºæ•°ç»„æˆ–å•ä¸ªå…ƒç´ 
                    let ctx = this.$refs['statChart' + index];
                    if (Array.isArray(ctx)) ctx = ctx[0];
                    // ä¿®å¤è‡ªåŠ¨åˆ·æ–°å¯¼è‡´canvasé«˜åº¦å¼‚å¸¸
                    if (ctx) {
                        ctx.height = 180;
                        // æ–°å¢ï¼šåŠ¨æ€è®¾ç½®canvaså®½åº¦ä¸ºçˆ¶å®¹å™¨å®½åº¦
                        const parent = ctx.parentElement;
                        if (parent) {
                            ctx.width = parent.clientWidth;
                        }
                    }
                    // æ ¹æ®å‘¨æœŸå¼ºåˆ¶å•ä½
                    let unit = 'MiB';
                    const period = this.stats[index].period;
                    if (period === 'd' || period === 'm') unit = 'GiB';
                    if (period === 'y') unit = 'TiB';
                    const { labels, rx, tx } = this.parseStatData(this.stats[index].data, unit);
                    if (!labels.length) return;
                    // å¹´ç»Ÿè®¡ç”¨æŸ±çŠ¶å›¾ï¼Œå…¶ä½™ç”¨æŠ˜çº¿å›¾
                    const chartType = period === 'y' ? 'bar' : 'line';
                    this._statCharts[index] = new Chart(ctx, {
                        type: chartType,
                        data: {
                            labels,
                            datasets: [
                                { label: `æ¥æ”¶(${unit})`, data: rx, backgroundColor: period === 'y' ? '#2563eb' : 'rgba(37,99,235,0.08)', borderColor: '#2563eb', tension: 0.3, fill: period !== 'y' },
                                { label: `å‘é€(${unit})`, data: tx, backgroundColor: period === 'y' ? '#fb923c' : 'rgba(251,146,60,0.08)', borderColor: '#fb923c', tension: 0.3, fill: period !== 'y' }
                            ]
                        },
                        options: {
                            responsive: true,
                            plugins: { legend: { display: true }, tooltip: { enabled: true } },
                            scales: { y: { beginAtZero: true, title: { display: true, text: unit } } }
                        }
                    });
                },
                // æ–°å¢ï¼šç»Ÿä¸€é‡ç»˜æ‰€æœ‰å›¾è¡¨ï¼ˆçª—å£resizeæ—¶è°ƒç”¨ï¼‰
                resizeAllCharts() {
                    // é‡æ–°æ¸²æŸ“åˆ†é’Ÿå›¾è¡¨
                    this.$nextTick(() => {
                        this.renderMinuteChart();
                        // é‡æ–°æ¸²æŸ“æ‰€æœ‰ç»Ÿè®¡å›¾è¡¨
                        if (this.stats && this.stats.length) {
                            this.stats.forEach((stat, idx) => this.renderStatChart(idx));
                        }
                    });
                },
                async loadStats(stat, index) {
                    stat.loading = true;
                    try {
                        const response = await axios.get(`/api/stats/${this.selectedInterface}/${stat.period}`);
                        stat.data = response.data.data;
                        this.$nextTick(() => this.renderStatChart(index));
                        // ç»Ÿä¸€å•ä½
                        const { labels, rx, tx } = this.parseStatData(stat.data);
                        const all = rx.concat(tx);
                        const { unit, factor } = this.getBestUnitAndFactor(all);
                        stat.unit = unit;
                        stat.factor = factor;
                    } catch (error) {
                        stat.data = ['é”™è¯¯: ' + (error.response?.data?.error || error.message)];
                    }
                    stat.loading = false;
                },
                async loadRealtimeStats() {
                    this.realtimeStats.loading = true;
                    try {
                        if (this.debugMode) console.log('å¼€å§‹åŠ è½½å®æ—¶ç»Ÿè®¡æ•°æ®...');
                        const response = await axios.get(`/api/stats/${this.selectedInterface}/l`);
                        
                        // è§£æå®æ—¶æ•°æ®
                        const rawData = response.data.data;
                        if (this.debugMode) console.log('æ”¶åˆ°åŸå§‹å®æ—¶æ•°æ®:', rawData);
                        
                        const parsedData = this.parseRealtimeData(rawData);
                        
                        if (parsedData) {
                            // æ·»åŠ åˆ°å†å²æ•°æ®ï¼Œä¿æŒæœ€è¿‘20æ¡
                            this.realtimeData.push(parsedData);
                            if (this.realtimeData.length > 20) {
                                this.realtimeData.shift();
                            }
                            
                            if (this.debugMode) console.log('å®æ—¶æ•°æ®è§£ææˆåŠŸï¼Œå½“å‰å†å²æ•°æ®æ¡æ•°:', this.realtimeData.length);
                            
                            // æ›´æ–°å›¾è¡¨å’Œè¡¨æ ¼
                            this.$nextTick(() => {
                                this.renderRealtimeChart();
                                this.renderRealtimeTable();
                            });
                        } else {
                            if (this.debugMode) console.warn('å®æ—¶æ•°æ®è§£æå¤±è´¥ï¼Œä½†ç»§ç»­æ˜¾ç¤ºåŸå§‹æ•°æ®');
                        }
                        
                        // ä¿æŒåŸæœ‰æ•°æ®æ ¼å¼ç”¨äºå…¼å®¹
                        this.realtimeStats.data = rawData.filter(line => line.trim());
                        
                        // ç¡®ä¿å›¾è¡¨å’Œè¡¨æ ¼å§‹ç»ˆæ›´æ–°
                        this.$nextTick(() => {
                            this.renderRealtimeChart();
                            this.renderRealtimeTable();
                        });
                        
                    } catch (error) {
                        console.error('åŠ è½½å®æ—¶ç»Ÿè®¡æ•°æ®å¤±è´¥:', error);
                        this.realtimeStats.data = ['é”™è¯¯: ' + (error.response?.data?.error || error.message)];
                        
                        // å³ä½¿å‡ºé”™ä¹Ÿè¦å°è¯•æ¸²æŸ“
                        this.$nextTick(() => {
                            this.renderRealtimeChart();
                            this.renderRealtimeTable();
                        });
                    }
                    this.realtimeStats.loading = false;
                },
                parseRealtimeData(rawData) {
                    // è§£æå®æ—¶æ•°æ®ï¼Œæå–é€Ÿåº¦å’Œæ•°æ®åŒ…ä¿¡æ¯
                    const receiveLine = rawData.find(line => line.includes('æ¥æ”¶'));
                    const sendLine = rawData.find(line => line.includes('å‘é€'));
                    
                    if (!receiveLine || !sendLine) {
                        if (this.debugMode) console.warn('å®æ—¶æ•°æ®è§£æå¤±è´¥ï¼šæœªæ‰¾åˆ°æ¥æ”¶æˆ–å‘é€è¡Œ', rawData);
                        return null;
                    }
                    
                    // å¢å¼ºçš„æ­£åˆ™è¡¨è¾¾å¼ï¼Œæ”¯æŒå¤šç§æ ¼å¼
                    // æ ¼å¼1: 12345                   // æ ¼å¼2: 123.45 kb/s 1234 packets/s
                    const speedPattern = /(\d+\.?\d*)\s*([kmg]?b\/ç§’).*?(\d+)\s*(æ•°æ®åŒ…|packets|åŒ…|p)\/s/i;
                    
                    // è§£ææ¥æ”¶æ•°æ®
                    const receiveMatch = receiveLine.match(speedPattern);
                    // è§£æå‘é€æ•°æ®
                    const sendMatch = sendLine.match(speedPattern);
                    
                    if (!receiveMatch || !sendMatch) {
                        if (this.debugMode) console.warn('å®æ—¶æ•°æ®è§£æå¤±è´¥ï¼šæ­£åˆ™åŒ¹é…å¤±è´¥', {
                            receiveLine,
                            sendLine,
                            receiveMatch,
                            sendMatch
                        });
                        return null;
                    }
                    
                    const now = new Date();
                    const parsedData = {
                        time: now.toLocaleTimeString(),
                        timestamp: now.getTime(),
                        receiveSpeed: parseFloat(receiveMatch[1]),
                        receiveSpeedUnit: receiveMatch[2],
                        receivePackets: parseInt(receiveMatch[3]),
                        sendSpeed: parseFloat(sendMatch[1]),
                        sendSpeedUnit: sendMatch[2],
                        sendPackets: parseInt(sendMatch[3])
                    };
                    
                    // éªŒè¯è§£æç»“æœ
                    if (isNaN(parsedData.receiveSpeed) || isNaN(parsedData.sendSpeed) || 
                        isNaN(parsedData.receivePackets) || isNaN(parsedData.sendPackets)) {
                        if (this.debugMode) console.warn('å®æ—¶æ•°æ®è§£æå¤±è´¥ï¼šæ•°å€¼è½¬æ¢å¤±è´¥', parsedData);
                        return null;
                    }
                    
                    if (this.debugMode) console.log('å®æ—¶æ•°æ®è§£ææˆåŠŸ:', parsedData);
                    return parsedData;
                },
                renderRealtimeChart() {
                    if (this._realtimeChart) this._realtimeChart.destroy();
                    const ctx = this.$refs.realtimeChart;
                    if (!ctx) {
                        if (this.debugMode) console.warn('å®æ—¶å›¾è¡¨æ¸²æŸ“å¤±è´¥ï¼šcanvaså…ƒç´ ä¸å­˜åœ¨');
                        return;
                    }
                    
                    // è®¾ç½®canvaså°ºå¯¸
                    ctx.height = 200;
                    const parent = ctx.parentElement;
                    if (parent) {
                        ctx.width = parent.clientWidth;
                    }
                    
                    // å‡†å¤‡å›¾è¡¨æ•°æ®ï¼ˆæœ€è¿‘1åˆ†é’Ÿï¼‰
                    const oneMinuteAgo = Date.now() - 1 * 60 * 1000;
                    const chartData = this.realtimeData.filter(item => item.timestamp >= oneMinuteAgo);
                    
                    // å¦‚æœæ²¡æœ‰æ•°æ®ï¼Œåˆ›å»ºé»˜è®¤æ•°æ®ç‚¹
                    let labels, receiveSpeeds, sendSpeeds;
                    if (chartData.length === 0) {
                        if (this.debugMode) console.log('å®æ—¶å›¾è¡¨ï¼šä½¿ç”¨é»˜è®¤æ•°æ®');
                        const now = new Date();
                        labels = [now.toLocaleTimeString()];
                        receiveSpeeds = [0];
                        sendSpeeds = [0];
                    } else {
                        labels = chartData.map(item => item.time);
                        receiveSpeeds = chartData.map(item => item.receiveSpeed);
                        sendSpeeds = chartData.map(item => item.sendSpeed);
                    }
                    
                    this._realtimeChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels,
                            datasets: [
                                { label: 'æ¥æ”¶é€Ÿåº¦', data: receiveSpeeds, borderColor: '#2563eb', backgroundColor: 'rgba(37,99,235,0.08)', tension: 0.3, fill: true },
                                { label: 'å‘é€é€Ÿåº¦', data: sendSpeeds, borderColor: '#fb923c', backgroundColor: 'rgba(251,146,60,0.08)', tension: 0.3, fill: true }
                            ]
                        },
                        options: {
                            responsive: true,
                            plugins: { 
                                legend: { display: true }, 
                                tooltip: { enabled: true } 
                            },
                            scales: { 
                                y: { 
                                    beginAtZero: true, 
                                    title: { display: true, text: 'é€Ÿåº¦' } 
                                } 
                            }
                        }
                    });
                },
                renderRealtimeTable() {
                    // ç”Ÿæˆè¡¨æ ¼HTML
                    let html = `<div style='font-weight:bold;margin-bottom:4px;'>å®æ—¶æµé‡ç»Ÿè®¡</div>`;
                    
                    if (this.realtimeData.length === 0) {
                        // æ˜¾ç¤ºåŸå§‹æ•°æ®ä½œä¸ºé™çº§æ–¹æ¡ˆ
                        html += `<div style="color:#666;font-style:italic;padding:10px;">æš‚æ— å®æ—¶æ•°æ®ï¼Œæ˜¾ç¤ºåŸå§‹æ•°æ®ï¼š</div>`;
                        if (this.realtimeStats.data && this.realtimeStats.data.length > 0) {
                            html += `<pre style="font-size:12px;background:#f8f9fa;padding:8px;border-radius:4px;">${this.realtimeStats.data.join('\n')}</pre>`;
                        } else {
                            html += `<div style="color:#999;text-align:center;padding:20px;">æš‚æ— æ•°æ®</div>`;
                        }
                    } else {
                        // æ˜¾ç¤ºè§£æåçš„æ•°æ®è¡¨æ ¼
                        const tableData = this.realtimeData.slice(-20); // æœ€è¿‘20æ¡
                        html += '<table class="table table-sm table-bordered mb-0" style="font-size:13px;">';
                        html += '<thead><tr><th>æ—¶é—´</th><th>æ¥æ”¶é€Ÿåº¦</th><th>æ¥æ”¶æ•°æ®åŒ…</th><th>å‘é€é€Ÿåº¦</th><th>å‘é€æ•°æ®åŒ…</th></tr></thead>';
                        html += '<tbody>';
                        
                        tableData.forEach((item, index) => {
                            const isLatest = index === tableData.length - 1;
                            const rowBg = isLatest ? '#e3f2fd' : (index % 2 === 0 ? '#fff' : '#f6f8fa');
                            const textColor = isLatest ? '#1976d2' : '';
                            html += `<tr style='background:${rowBg};${textColor ? 'color: ' + textColor + ';font-weight:bold;' : ''}'>`;
                            html += `<td>${item.time}</td>`;
                            html += `<td style='color:#2563eb;font-weight:500;'>${item.receiveSpeed} ${item.receiveSpeedUnit}</td>`;
                            html += `<td style='color:#2563eb;font-weight:500;'>${item.receivePackets} åŒ…/s</td>`;
                            html += `<td style='color:#fb923c;font-weight:500;'>${item.sendSpeed} ${item.sendSpeedUnit}</td>`;
                            html += `<td style='color:#fb923c;font-weight:500;'>${item.sendPackets} åŒ…/s</td>`;
                            html += '</tr>';
                        });
                        
                        html += '</tbody></table>';
                    }
                    
                    // æ›´æ–°è¡¨æ ¼å†…å®¹
                    if (this.$refs.realtimeTable) {
                        this.$refs.realtimeTable.innerHTML = html;
                    } else {
                        if (this.debugMode) console.warn('å®æ—¶è¡¨æ ¼æ¸²æŸ“å¤±è´¥ï¼šrealtimeTableå…ƒç´ ä¸å­˜åœ¨');
                    }
                },
                async loadMinuteStats() {
                    this.minuteStats.loading = true;
                    try {
                        const response = await axios.get(`/api/stats/${this.selectedInterface}/5`);
                        this.minuteStats.data = response.data.data.filter(line => line.trim());
                        this.$nextTick(() => this.renderMinuteChart());
                        // ç»Ÿä¸€å•ä½
                        const { labels, rx, tx } = this.parseStatData(this.minuteStats.data);
                        const all = rx.concat(tx);
                        const { unit, factor } = this.getBestUnitAndFactor(all);
                        this.minuteStats.unit = unit;
                        this.minuteStats.factor = factor;
                    } catch (error) {
                        this.minuteStats.data = ['é”™è¯¯: ' + (error.response?.data?.error || error.message)];
                    }
                    this.minuteStats.loading = false;
                },
                loadAllStats() {
                    this.loadRealtimeStats();
                    this.loadMinuteStats();
                    this.stats.forEach((stat, idx) => this.loadStats(stat, idx));
                    this.updateLastUpdateTime();
                },
                updateLastUpdateTime() {
                    const now = new Date();
                    this.lastUpdateTime = now.toLocaleTimeString();
                },
                startAutoRefresh() {
                    if (this.refreshInterval) {
                        clearInterval(this.refreshInterval);
                    }
                    if (this.autoRefresh) {
                        this.refreshInterval = setInterval(() => {
                            this.loadRealtimeStats();
                            this.updateLastUpdateTime();
                        }, 1000);

                        setInterval(() => {
                            this.loadMinuteStats();
                        }, 5000);

                        setInterval(() => {
                            this.stats.forEach(stat => this.loadStats(stat));
                        }, 60000);
                    }
                },
                async loadVersion() {
                    try {
                        const response = await axios.get('/api/version');
                        this.version = response.data.version;
                    } catch (error) {
                        console.error('è·å–ç‰ˆæœ¬å·å¤±è´¥:', error);
                    }
                },
                async queryDateRange() {
                    if (!this.isDateRangeValid) return;
                    
                    this.dateRangeStats.loading = true;
                    try {
                        const response = await axios.get(
                            `/api/stats/${this.selectedInterface}/range/${this.dateRange.start}/${this.dateRange.end}`
                        );
                        this.dateRangeStats.data = response.data.data;
                    } catch (error) {
                        this.error = 'æŸ¥è¯¢å¤±è´¥: ' + (error.response?.data?.error || error.message);
                    }
                    this.dateRangeStats.loading = false;
                },
                clearDateRangeStats() {
                    this.dateRangeStats.data = [];
                    this.dateRange.start = '';
                    this.dateRange.end = '';
                },
                // æ–°ï¼šå°†æ ¼å¼åŒ–åçš„æ•°æ®æ¸²æŸ“ä¸ºHTMLè¡¨æ ¼
                renderTableHtml(data, unit) {
                    if (!data || data.length === 0) return '';
                    // ç¬¬ä¸€è¡Œä¸ºæ ‡é¢˜ï¼ˆå¦‚ eth0 / 5 minuteï¼‰ï¼Œå•ç‹¬ä¸€è¡Œ
                    let html = `<div style='font-weight:bold;margin-bottom:4px;'>${data[0]}</div>`;
                    // ç¬¬äºŒè¡Œä¸ºè¡¨å¤´ï¼Œä¸¥æ ¼ä¿è¯5åˆ—ï¼šå…ˆç”¨|åˆ†å‰²ï¼Œç¬¬ä¸€ä¸ªåˆ†æ®µå†ç”¨å¤šç©ºæ ¼åˆ†å‰²
                    let headerLine = data[1];
                    let header = [];
                    if (headerLine.includes('|')) {
                        const segs = headerLine.split('|');
                        header = segs[0].trim().split(/\s{2,}/).map(h => h.trim());
                        for (let i = 1; i < segs.length; i++) {
                            if (segs[i].trim()) header.push(segs[i].trim());
                        }
                    } else {
                        header = headerLine.split(/\s{2,}/).map(h => h.trim());
                    }
                    // è®°å½•å…³é”®åˆ—ç´¢å¼•
                    const rxIdx = header.findIndex(h => h.includes('æ¥æ”¶'));
                    const txIdx = header.findIndex(h => h.includes('å‘é€'));
                    const totalIdx = header.findIndex(h => h.includes('æ€»è®¡'));
                    const avgIdx = header.findIndex(h => h.includes('å¹³å‡é€Ÿç‡'));
                    html += '<table class="table table-sm table-bordered mb-0" style="font-size:13px;">';
                    html += '<thead><tr>' + header.map(h => `<th>${h}</th>`).join('') + '</tr></thead>';
                    html += '<tbody>';
                    // å…¶ä½™ä¸ºæ•°æ®è¡Œï¼Œåˆ†å‰²æ–¹å¼åŒä¸Š
                    let dataRowIdx = 0;
                    for (let i = 2; i < data.length; i++) {
                        let line = data[i];
                        if (line.includes('---')) continue;
                        let cols = [];
                        if (line.includes('|')) {
                            const segs = line.split('|');
                            cols = segs[0].trim().split(/\s{2,}/).map(c => c.trim());
                            for (let j = 1; j < segs.length; j++) {
                                if (segs[j].trim()) cols.push(segs[j].trim());
                            }
                        } else {
                            cols = line.split(/\s{2,}/).map(c => c.trim());
                        }
                        if (cols.length === 1 && !cols[0]) continue;
                        // æ–‘é©¬çº¹èƒŒæ™¯è‰²
                        const rowBg = dataRowIdx % 2 === 0 ? '#fff' : '#f6f8fa';
                        html += `<tr style='background:${rowBg};'>` +
                            cols.map((c, idx) => {
                                let style = '';
                                if (idx === rxIdx) style = 'color:#2563eb;font-weight:500;'; // ç°ä»£è“
                                if (idx === txIdx) style = 'color:#fb923c;font-weight:500;'; // ç°ä»£æ©™
                                if (idx === totalIdx) style = 'color:#14b8a6;font-weight:500;'; // ç°ä»£é’ç»¿
                                if (idx === avgIdx) style = 'color:#64748b;font-weight:500;'; // ç°ä»£è“ç°
                                return `<td style='${style}'>${c}</td>`;
                            }).join('') + '</tr>';
                        dataRowIdx++;
                    }
                    html += '</tbody></table>';
                    return html;
                },
                toggleTheme() {
                    this.isDarkMode = !this.isDarkMode;
                    document.body.classList.toggle('dark', this.isDarkMode);
                    localStorage.setItem('theme', this.isDarkMode ? 'dark' : 'light');
                },
                toggleDebugMode() {
                    this.debugMode = !this.debugMode;
                    localStorage.setItem('debugMode', this.debugMode);
                },
                applyThemeFromPreference() {
                    // ä¼˜å…ˆç”¨æˆ·é€‰æ‹©ï¼Œé»˜è®¤æµ…è‰²æ¨¡å¼
                    const userTheme = localStorage.getItem('theme');
                    if (userTheme === 'dark') {
                        this.isDarkMode = true;
                        document.body.classList.add('dark');
                    } else {
                        // é»˜è®¤æµ…è‰²æ¨¡å¼ï¼Œç§»é™¤ç³»ç»Ÿä¸»é¢˜è·Ÿéš
                        this.isDarkMode = false;
                        document.body.classList.remove('dark');
                    }
                    // åº”ç”¨è°ƒè¯•æ¨¡å¼ï¼Œé»˜è®¤å…³é—­
                    const userDebugMode = localStorage.getItem('debugMode');
                    this.debugMode = (userDebugMode === 'true');
                }
            },
            watch: {
                autoRefresh(newValue) {
                    if (newValue) {
                        this.startAutoRefresh();
                    } else {
                        clearInterval(this.refreshInterval);
                    }
                }
            },
            mounted() {
                this.loadInterfaces();
                this.startAutoRefresh();
                this.loadVersion();
                this.applyThemeFromPreference();
                // æ–°å¢ï¼šç›‘å¬çª—å£resizeäº‹ä»¶
                window.addEventListener('resize', this.resizeAllCharts);
                
                // æµ‹è¯•å®æ—¶ç»Ÿè®¡åŠŸèƒ½
                if (this.debugMode) {
                    console.log('FlowMaster å®æ—¶ç»Ÿè®¡åŠŸèƒ½æµ‹è¯•å¼€å§‹...');
                    // æ¨¡æ‹Ÿæµ‹è¯•æ•°æ®
                    setTimeout(() => {
                        if (this.realtimeData.length === 0) {
                            console.warn('æµ‹è¯•ï¼šå®æ—¶æ•°æ®ä¸ºç©ºï¼Œé™çº§æ˜¾ç¤ºæœºåˆ¶åº”è¯¥ç”Ÿæ•ˆ');
                        } else {
                            console.log('æµ‹è¯•ï¼šå®æ—¶æ•°æ®æ­£å¸¸ï¼Œå…±', this.realtimeData.length, 'æ¡è®°å½•');
                        }
                    }, 3000);
                }
            },
            beforeUnmount() {
                if (this.refreshInterval) {
                    clearInterval(this.refreshInterval);
                }
                if (this._minuteChart) this._minuteChart.destroy();
                if (this._statCharts) this._statCharts.forEach(chart => chart.destroy());
                if (this._realtimeChart) this._realtimeChart.destroy(); // ç§»é™¤å®æ—¶å›¾è¡¨
                // æ–°å¢ï¼šç§»é™¤resizeäº‹ä»¶ç›‘å¬
                window.removeEventListener('resize', this.resizeAllCharts);
            }
        });

        app.mount('#app');
    </script>

    <!-- 51.la ç»Ÿè®¡ä»£ç  -->
    <script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
    <script>LA.init({id:"24WADmnDKAw7Dh8r",ck:"24WADmnDKAw7Dh8r"})</script>

</body>
</html> 